+++
date = '2025-12-09'
draft = false
title = 'leecode Hot100 学习记录'

tags = ["前缀和"]

categories = ["算法题"]

+++



### 前缀和

> **不单调数组求任意子数组和**

前缀和概念和数列前n项和的概念很像，但是不包含最后一项（左闭右开），模版来自[303. 区域和检索 - 数组不可变 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-immutable/)

主要特点是，通过定义一个数组前缀和，就可以只需要O(1)复杂度求出任意一个子数组的和结果。

```java
//leecode303.区域和检索：计算前缀和的模版实现

public class NumArray {
    private final int [] s;
    public NumArray(int [] nums) {
        s = new int [nums.length+1];
        for (int i = 0; i <nums.length; i++) {
            s[i+1] =s[i] + nums[i];//默认定义了s【0】为0
        }
    }
    public int sumRange(int left, int right) {
        return s[right+1]-s[left];
    }
}
```

应用这个定义可以做[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

**Q：为什么要用前缀和？**

A：因为这个待求的数组是**不单调**的。使用前缀和定义的数据结构，**两个值相减可以求出来任意一个子数组的和**。滑动窗口需要满足单调性，当右端点元素进入窗口时，窗口元素和是不能减少的。本题 nums 包含负数，当负数进入窗口时，窗口左端点该往哪个方向移动？无法确定。如果没有负数的话，则可以用滑动窗口。

于是转换成 **s[j]-s[i] = k** 这样的问题。可以看成是两数之和的变种。

**s[j] = k + s[i]  => s[right]-k = s[left]** , 然后使用哈希表，快速定位是否存在，存在了就说明加1，最后合并所有的值。这里注意必须要用sj-k而不是si+k。这是因为，我们需要进行遍历来填充哈希表，在遍历的过程中去寻找符合条件的i与j。由于j大于i，也就是说，我们只有先知道了j才能知道i。遍历过程是只能先知道遍历到的元素的值，是只能给遍历过的元素key赋值value的。因此，我们只能求得si。因为si表示就是在当前元素sj之前的元素。

> **两数之和变体：选择更大的那个值与target计算，求之前遍历过的是否存在小的那个值。**

```java
public int subarraySum(int[] nums, int k) {
        int [] s = new int[nums.length+1];
        for (int i=0;i<nums.length;i++){
            s[i+1] =  s[i]+nums[i];
        }
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <s.length ; i++) {
            ans += map.getOrDefault(s[i]-k,0);//查询已有的哈希表
            map.put(s[i],map.getOrDefault(s[i],0)+1);//创建前缀和的值的哈希表元素
        }
        return ans;
    }
```



