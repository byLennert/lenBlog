+++
date = '2025-12-09'
draft = false
title = 'leecode Hot100 学习记录'

tags = ["前缀和"]

categories = ["算法题"]

+++





### 前缀和

> **不单调数组求任意子数组和**

前缀和概念和数列前n项和的概念很像，但是不包含最后一项（左闭右开），模版来自[303. 区域和检索 - 数组不可变 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-immutable/)

主要特点是，通过定义一个数组前缀和，就可以只需要O(1)复杂度求出任意一个子数组的和结果。

```java
//leecode303.区域和检索：计算前缀和的模版实现

public class NumArray {
    private final int [] s;
    public NumArray(int [] nums) {
        s = new int [nums.length+1];
        for (int i = 0; i <nums.length; i++) {
            s[i+1] =s[i] + nums[i];//默认定义了s【0】为0
        }
    }
    public int sumRange(int left, int right) {
        return s[right+1]-s[left];
    }
}
```

应用这个定义可以做[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

**Q：为什么要用前缀和？**

A：因为这个待求的数组是**不单调**的。使用前缀和定义的数据结构，**两个值相减可以求出来任意一个子数组的和**。滑动窗口需要满足单调性，当右端点元素进入窗口时，窗口元素和是不能减少的。本题 nums 包含负数，当负数进入窗口时，窗口左端点该往哪个方向移动？无法确定。如果没有负数的话，则可以用滑动窗口。

于是转换成 **s[j]-s[i] = k** 这样的问题。可以看成是两数之和的变种。

**s[j] = k + s[i]  => s[right]-k = s[left]** , 然后使用哈希表，快速定位是否存在，存在了就说明加1，最后合并所有的值。这里注意必须要用sj-k而不是si+k。这是因为，我们需要进行遍历来填充哈希表，在遍历的过程中去寻找符合条件的i与j。由于j大于i，也就是说，我们只有先知道了j才能知道i。遍历过程是只能先知道遍历到的元素的值，是只能给遍历过的元素key赋值value的。因此，我们只能求得si。因为si表示就是在当前元素sj之前的元素。

> **两数之和变体：选择更大的那个值与target计算，求之前遍历过的是否存在小的那个值。**

```java
public int subarraySum(int[] nums, int k) {
        int [] s = new int[nums.length+1];
        for (int i=0;i<nums.length;i++){
            s[i+1] =  s[i]+nums[i];
        }
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <s.length ; i++) {
            ans += map.getOrDefault(s[i]-k,0);//查询已有的哈希表
            map.put(s[i],map.getOrDefault(s[i],0)+1);//创建前缀和的值的哈希表元素
        }
        return ans;
    }
```

同样的问题可以解决：[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

实际上这个需要计算最大数组和，多考虑一步就是如何得到最大数组和，s[i] - min（s[k])。我们依旧遍历一次前缀数组，但是我们记录前缀数组最小的部分在哪里，然后用当前的和减去之前的最小的和，可以求得当前最大的值。遍历一轮不停更新最小的和与最大的值，就可以得到最终的结果了。注意：min需要从s[0]开始，而这道题目必须要先比较最大值，再更新最小和，否则会将只有一个元素的数组误求成0。

```java
public int maxSubArray(int[] nums) {
           int []sum =  new int[nums.length+1];
           for (int i = 0; i < nums.length; i++) {
                    sum[i+1] = sum[i] + nums[i];
           }//求出前缀和数组
           int min = 0;
           int maxVal = Integer.MIN_VALUE;
           for (int i = 1; i < sum.length; i++) {
               if (sum[i]-min > maxVal){
                   maxVal = sum[i]-min;
               }
               if (sum[i] < min){
                   min = sum[i];
               }
           }
           return maxVal;
    }
```





### 滑动窗口求最大值

使用方法：单调队列

>  **“及时去除无用数据，保证双端队列有序”**

> [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/solutions/2499715/shi-pin-yi-ge-shi-pin-miao-dong-dan-diao-ezj6/?envType=study-plan-v2&envId=top-100-liked)

模拟滑动窗口的过程，发现：如果新加入的比前面的大，那么很可能是窗口最大值。而前面已经加入的肯定不可能是最大值（要比更大的先脱离窗口）；而新加入的比前面的小的时候，新加入的元素仍然有可能变成最大值（当后来的逗比新加入的小）

所以最后我们希望记录下最可能成为最大值的元素，而去掉不可能成为最大值的元素，构成了一个单调的变动的集合。最终我们需要的数据结构是左出右进/右出的结构，因此使用的是双端队列。

由于队列维护的结构都是单调的，因此这个方法也叫做**单调队列**。

> 说实在的，理解这道题突然有点破防：后来进滑动窗口的一定比窗口里面的更加**’‘年轻‘’**，新来的寿命比你长，**价值**还比你大，凭什么还留着你个老登。你不可能成为最大的那个了。如果新来的没你有价值，其实你还是有可能成为最大的地位的。退位也是以后的事。

具体代码如下：每个元素只会进一次队列出一次队列，虽然看着是两个循环，但是时间复杂度是O（n），空间复杂度是O（k）

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length-k+1];
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++) {
//           进
            while (!q.isEmpty() && nums[q.getLast()] < nums[i] ) {
                //后来者更大，需要删除已有的最新的，保证只留下最可能成为最大值的,可能要去掉多个所以用的是while而不是if
                q.removeLast();
            }
            q.addLast(i);
//            出，能出or该出就出
            int left = i-k+1;
            if (left >q.getFirst() ) {
                q.removeFirst();
            }
//            记录元素
            if (left>=0){
                ans[left]=nums[q.getFirst()];
            }
        }
        return ans;
    }
}
```

其他单调队列题目：

- [ ]  绝对差不超过限制的最长连续子数组 https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ 
- [ ] 预算内的最多机器人数目 https://leetcode.cn/problems/maximum-number-of-robots-within-budget/
- [ ] 和至少为 K 的最短子数组 https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/
- [ ] 满足不等式的最大值 https://leetcode.cn/problems/max-value-of-equation/ 
- [ ]  跳跃游戏 VI https://leetcode.cn/problems/jump-game-vi/ 
- [ ] 购买水果需要的最少金币数 https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/



### 覆盖子串类问题

使用方法：数组记录每个字母出现次数，然后比较。

今天自己写出来的第一个`hard`题目:smile:（虽然判断函数的逻辑有问题抄的灵神的，但是主要逻辑都是自己一气呵成的！大大的进步！）

> [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)

思路：这类题目给定一个长的串s，给定一个短串t。核心在于如何判断是否s的子串包含t。这个题目要求的是只要**覆盖**了就行。如abvc覆盖了abc。核心在于写判断什么时候覆盖的逻辑。需要自定义一个函数进行判断。主要逻辑就是滑动窗口来收集所有的覆盖t的子串，然后记录到哈希表里面最后拿出最小的那个就行。

**时间复杂度：O(52 \* n) = O(n)**，其中n是字符串s的长度

1. **isCovered方法**：每次调用需要遍历52个字符（26个大写字母 + 26个小写字母），时间复杂度O(52)
2. **minWindow方法**：
   - 初始化：O(|t|)，统计t中字符频率
   - 双指针遍历：O(n)，n是s的长度
   - 每次移动指针时可能调用isCovered：最坏情况下O(52*n)

具体个人代码如下：

```java
class Solution {
   private boolean isCovered(int[] cntS, int[] cntT) {
        for (int i = 'A'; i <= 'Z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;//反着来快，有一个反例就不行
            }
        }
        for (int i = 'a'; i <= 'z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }
        return true;
    }

      public String minWindow(String s, String t) {
        int [] countT = new int[128];
        int [] countS = new int[128];
        Map<Integer,String> map = new HashMap<>();
        int min = Integer.MAX_VALUE;
        for (int i=0;i<t.length();i++){
            countT[t.charAt(i)]++;
        }//统计出来每个字母的频率
        int left = 0;
        int right = 0;
        while (right < s.length()){
            countS[s.charAt(right)]++;
            right++;
            if (isCovered(countS, countT)){
                while(left<right && isCovered(countS, countT)){
                    countS[s.charAt(left)]--;
                    left++;//这个left一定会加，好处就是实际上最后的left一定是新的滑动窗口起点，继续找子串，而不是停留在原地陷入死循环。
                }
                map.put(right-left+1,s.substring(left-1,right)) ;//这里得注意，left一定要减一，right前面也是加了之后的所以直接用就行。substring是左闭右开，这里不需要用right+1；
                min = Math.min(min,right-left+1);
            }
        }
        if (map.containsKey(min)){
            return map.get(min);
        }
    return "";
    }
}
```



### 数组

#### 区间合并问题

使用方法：排序

> [56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-100-liked)

合并区间的关键在于，必须先都按照左端点进行排序，这样就可以仅关注右边端点。一旦出现下一个左端点是大于当前的右端的值，那么当前的区间一定就是固定的结果区间了。因为排序之后不存在后面的其他区间左端点比下一个左端点小。

两个关键代码：写排序的比较器；写比较过程的分支结构

关于比较器：

`Comparator` 是 Java 中的一个函数式接口，位于 `java.util` 包下。它定义了一个用于比较两个对象的方法 `compare`，该方法接受两个参数，并返回一个整数值。返回值的含义如下：

- 如果返回值小于 0，表示第一个参数小于第二个参数。
- 如果返回值等于 0，表示两个参数相等。
- 如果返回值大于 0，表示第一个参数大于第二个参数。

也就是说，如果写（a,b）->return a - b; 就肯定是正序了，因为如果a大，那么返回的就是正数，而a实际就会排在后面了。反之，如果写成return b-a，那么就是倒序，因为b大，返回正数，让a排在了b的前面。也就是说，返回值的符号实际上表示了第一个参数和第二个参数的关系，谁小谁在前，谁大谁靠后，然后才看出来是不是正序/倒序。

具体代码如下：

```java
 public int[][] merge(int[][] intervals) {
        List<int []> ans = new ArrayList<>();
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);//正序排序左端点
        for (int i = 0; i < intervals.length; i++) {
            if (!ans.isEmpty() && ans.getLast()[1]>=intervals[i][0]){
                ans.getLast()[1]=Math.max(ans.getLast()[1],intervals[i][1]);
            }else  {
                ans.addLast(intervals[i]);
            } 
        }
        return ans.toArray(new int[ans.size()][]);
    }
```

#### 轮转数组

关键在于两个注意点：

一是要将k取模，大于数组长度的k相当于先转一圈（没变）再转几个，需要防止数组越界；

二是了解java特性，java没有指针，传递的是数组的引用。在Java中，数组是对象，所以当数组作为参数传递时，传递的是**引用（内存地址）**，而不是数组本身的副本。

```java
class Solution {
    public void ratateUtil(int [] nums,int start,int end){
        int l = start;
        int r = end;
        while( l < r){
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }

    public void rotate(int[] nums, int k) {
            k = k % nums.length;
            ratateUtil(nums,0,nums.length-1);
            ratateUtil(nums,0,k-1);
            ratateUtil(nums,k,nums.length-1);
        
        
    }
}
```

####  求除自身外数组乘积

题目[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

关键点：这道题目不能用除法，要模仿前缀和的方法，实际上可以用前缀乘积和后缀乘积来做。直接用前缀*后缀就可以了。

```java
//普通方法
public int[] productExceptSelf(int[] nums) {
//        先计算前缀后缀
        int [] pre =  new int[nums.length+1];
        pre[0] = 1;
        int [] suf =  new int[nums.length+1];
        suf[nums.length-1] =1;//注意前缀和后缀的初始化都是基于源数组的起始和末尾的，乘积所以用1初始化
        for (int i = 1; i <=nums.length; i++){
            pre[i] = pre[i-1]*nums[i-1];
        }
        for (int i = nums.length-2; i >=0; i--){
            suf[i] = suf[i+1]*nums[i+1];
        }
    
        int []res =  new int[nums.length];
        for(int i =0;i<nums.length;i++){
            res[i] = pre[i]*suf[i];
        }
        return res;
    }



//优化空间复杂度的方法
public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] suf = new int[n];
        suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        int pre = 1;
        for (int i = 0; i < n; i++) {
            // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中
            suf[i] *= pre;
            pre *= nums[i];
        }

        return suf;
    }


```

#### 缺失的第一个正数

题目：[41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/submissions/684702448/?envType=study-plan-v2&envId=top-100-liked)

注意：这道题目需要时间复杂度为O(n)，空间复杂度为O(1)。所以核心在于交换，我们的排查方式就是让每个数归位到正确的位置上，然后从头开始找第一个不在位置的正数；如果找不到就是n+1。

- 缺失的第一个正数表明一定是范围在1-n，不可能更大，作为交换判断的条件。这种场景下的交换排序的时间复杂度依旧是O（n）
- 一直换到当前的位置变成正确的值。

```java
 public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            //给数组的每个数找他们应该在的位置，发现不对就交换。让原本的数组从1开始。所以这里用的是=nums[nums[i]-1]
            while(nums[i]>=1 && nums[i]<=nums.length && nums[i]!=nums[nums[i]-1]){
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
            }
        }
     //因此这里的判断是i+1，因为当前格子实际数组是1-n的顺序，是比索引大一。
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i+1) {
                return i+1;
            }
        }
        return nums.length+1;
    }
```

### 矩阵

#### 螺旋矩阵

重点在于使用一个二维数组当做下一步的方向上的增减，并提前预判下一步是否超界或者遍历过，根据条件转向。

![image-20251220192703470](https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202512201927061.png)

```java
public List<Integer> spiralOrder(int[][] matrix) {
        int m =  matrix.length;
        int n = matrix[0].length;
        List<Integer> ans = new ArrayList<>();
        int[][] copy = new int[m][n];//防止更改原本的数组
        for (int i = 0; i < matrix.length; i++) {
            copy[i] = Arrays.copyOf(matrix[i], matrix[i].length);
        }
        int [][]DIRECTION = new int [][]{{0,1},{1,0},{0,-1},{-1,0}};
        int i=0,j=0;
        int di = 0;//表示现在是哪个方向
        for (int k = 0; k < n*m; k++) {
            ans.add(matrix[i][j]);
            copy[i][j] = Integer.MAX_VALUE;
            int x = i+DIRECTION[di][0];
            int y = j+DIRECTION[di][1];
            if (x<0 || x>=m || y<0 || y>=n || copy[x][y]==Integer.MAX_VALUE) {
                di = (di+1) % 4;//该转向了
            }
            i = i+DIRECTION[di][0];
            j = j+DIRECTION[di][1];
        }

        return ans;
    }
```

#### 顺时针旋转矩阵

> [48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)

代码很简单，一次转置+一次横对称。但是原理需要理解：

**顺时针旋转90°的具体实现**

对于顺时针旋转90°：

- θ = 90°，所以两条对称轴夹角应为45°
- 具体操作：
  1. 先关于**主对角线**翻转（左上到右下的对角线）
  2. 再关于**垂直中轴**翻转（矩阵的垂直中线）

![image-20251220195528875](https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202512201955256.png)

```java
   public void rotate(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < i; j++) {//转置只对对角线下的元素操作。
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length/2; j++) {
                int temp  = matrix[i][j];
                matrix[i][j] = matrix[i][matrix[i].length-j-1];//对称交换
                matrix[i][matrix[i].length-j-1] = temp;
            }
        }
    }
```

#### 二维有序矩阵查找

笨办法就是每行用个二分法。

记得用优化后的写法：int mid = left + (right-left)/2;

灵神的写法是，每次只看右上角的：大就删列，小就删行。

时间复杂度O（m+n）

```java
public boolean searchMatrix(int[][] matrix, int target) {
       int i = 0;
       int j = matrix[0].length-1;
       while (i < matrix.length && j >= 0){
           if (matrix[i][j] == target){
               return true;
           }else if (matrix[i][j] > target){
               j--;
           }else {
               i++;
           }
       }
        return false;
    }
```

### 链表

#### 相交链表

其实这个题我会，但是灵神的代码实在太牛逼了，记一下

**这个代码是寻找两个链表的交点。**

原理：
两个指针分别从两个链表头开始，同步前进。当一个指针到达链表末尾时，它跳到另一个链表的头继续前进。这样两个指针走过的总路程相同，如果有交点，它们最终会在交点处相遇。

```java
class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        while (p != q) {
            p = p != null ? p.next : headB;
            q = q != null ? q.next : headA;
        }
        return p;
    }
}
```



#### 两数相加

> [2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked)

主要是为了看下简便的写法：

1. **更优雅的边界处理**：循环条件`while (l1 != null || l2 != null || carry != 0)`确保所有情况都被处理，包括最后可能的进位。
2. **统一的节点创建**：不再需要多个if-else分支来决定是否创建新节点，而是统一创建新节点并更新carry值。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0); // 虚拟头节点
        ListNode curr = dummy;
        int carry = 0;
        
        while (l1 != null || l2 != null || carry != 0) {//概括三种情况
            int x = (l1 != null) ? l1.val : 0;//第一条链表的值
            int y = (l2 != null) ? l2.val : 0;//第二条链表的值
            int sum = carry + x + y;//暂时的和
            
            carry = sum / 10;//是否进位
            curr.next = new ListNode(sum % 10);//结果
            curr = curr.next;//下一个
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        return dummy.next;
    }
}

```

#### 删除链表节点

> [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked)

换句话说，**如果遇到需要删除头节点的题目，添加哨兵节点可以简化代码逻辑**，请记住这个技巧。

>  加了一个头结点之后，删除时候就不需要额外讨论删除头结点的问题，如果真要讨论就看fast的状态，根据fast的位置判断是否删除头。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode pHead = new ListNode(0);
        pHead.next = head;
        ListNode fast = pHead;
        ListNode slow = pHead;
        int count = 0;
        while(fast!=null&&count<n){
            fast = fast.next;
            count++;
        }
        while(fast!=null && fast.next!=null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;

        return pHead.next;
    }
```

#### 反转链表II

```java
//反转链表2-片段反转  需要哨兵+pre /cur/next三个指针保证当前指向前面的，最后连接原链表和反转后的尾巴和头部。返回哨兵下一个
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new  ListNode(0) ;
        dummy.next = head;
        ListNode p = dummy;
        int count = 0;
        while (count < left-1) {
            p = p.next;
            count++;
        }//p在left前一个，从这里开始反转
        ListNode pre = null;
        ListNode cur = p.next;
        while (count < right) {//遍历最后一次结束cur是反转的下一个，pre时反转的最后一个
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
            count++;
        }
        p.next.next = cur;
        p.next = pre;
        return dummy.next;
    }
```

k个反转链表同上道理，多统计一次长度，加更新p0

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 统计节点个数
        int n = 0;
        for (ListNode cur = head; cur != null; cur = cur.next) {
            n++;
        }

        ListNode dummy = new ListNode(0, head);
        ListNode p0 = dummy;
        ListNode pre = null;
        ListNode cur = head;

        // k 个一组处理
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; i++) { // 同 92 题
                ListNode nxt = cur.next;
                cur.next = pre; // 每次循环只修改一个 next，方便大家理解
                pre = cur;
                cur = nxt;
            }

            // 见视频
            ListNode nxt = p0.next;
            p0.next.next = cur;
            p0.next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/1992228/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### 链表排序

使用分治思想，递归执行 分成两个链表、两个链表排序、合并有序链表。

需要注意的是，这里的分成两个链表一定要保证能断开，可以用两个节点长度的链表进行实验，进行分割。

要么是在取得中间节点时候多加一个指针pre，然后找到slow之后，pre操作断开。（推荐）

要么就获取前半个末端然后手动断开。代码用的第一种，更加简便。

```java
class Solution {
    public ListNode sortList(ListNode head) {
        // 如果链表为空或者只有一个节点，无需排序
        if (head == null || head.next == null) {
            return head;
        }
        // 找到中间节点 head2，并断开 head2 与其前一个节点的连接
        // 比如 head=[4,2,1,3]，那么 middleNode 调用结束后 head=[4,2] head2=[1,3]
        ListNode head2 = middleNode(head);
        // 分治
        head = sortList(head);
        head2 = sortList(head2);
        // 合并
        return mergeTwoLists(head, head2);
    }

    // 876. 链表的中间结点（快慢指针）
    private ListNode middleNode(ListNode head) {
        ListNode pre = head;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            pre = slow; // 记录 slow 的前一个节点
            slow = slow.next;
            fast = fast.next.next;
        }
        pre.next = null; // 断开 slow 的前一个节点和 slow 的连接
        return slow;
    }

    // 21. 合并两个有序链表（双指针）
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(); // 用哨兵节点简化代码逻辑
        ListNode cur = dummy; // cur 指向新链表的末尾
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1; // 把 list1 加到新链表中
                list1 = list1.next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur.next = list2; // 把 list2 加到新链表中
                list2 = list2.next;
            }
            cur = cur.next;
        }
        cur.next = list1 != null ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }
}
```

#### 多个有序链表合并

这道题目笨办法可以循环逐个进行两两合并的方法，但是更好的办法在于，所有的链表都是有序的可以进行使用堆排序，用优先队列不断维护一个最小节点的堆。每次仅加入头结点（头结点都是最小的）

```java
public ListNode mergeKLists(ListNode[] lists) {
    // 创建优先队列（最小堆），按照节点值升序排列
    PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
    // 将每个链表的头节点（非空）加入优先队列
    for (ListNode node : lists) {
        if (node != null) {
            pq.offer(node);
        }
    } 
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;
    // 当优先队列不为空时，循环处理
    while (!pq.isEmpty()) {
        // 弹出堆顶元素（当前所有链表头节点中的最小值）
        ListNode node = pq.poll();
        // 将最小节点连接到结果链表中
        cur.next = node;
        cur = cur.next;      
        // 如果该节点有后续节点，将其加入优先队列
        if (node.next != null) {
            pq.offer(node.next);
        }
    } 
    return dummy.next;
}
```

#### LRU 缓存

> [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)

这道题目如果是纯实现要用linkedhashmap，但是算法面试需要自己实现双链表。借用灵神的图和代码。

![图解 LRU](https://pic.leetcode.cn/1696039105-PSyHej-146-3-c.png)

问：需要几个哨兵节点？

答：一个就够了。一开始哨兵节点 dummy 的 prev 和 next 都指向 dummy。随着节点的插入，dummy 的 next 指向链表的第一个节点（最上面的书），prev 指向链表的最后一个节点（最下面的书）。

问：为什么节点要把 key 也存下来？

答：在删除链表末尾节点时，也要删除哈希表中的记录，这需要知道末尾节点的 key。

```java
class LRUCache {
    private static class Node {
        int key, value;
        Node prev, next;

        Node(int k, int v) {
            key = k;
            value = v;
        }
    }

    private final int capacity;
    private final Node dummy = new Node(0, 0); // 哨兵节点
    private final Map<Integer, Node> keyToNode = new HashMap<>();

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummy.prev = dummy;
        dummy.next = dummy;
    }

    public int get(int key) {
        Node node = getNode(key); // getNode 会把对应节点移到链表头部
        return node != null ? node.value : -1;
    }

    public void put(int key, int value) {
        Node node = getNode(key); // getNode 会把对应节点移到链表头部
        if (node != null) { // 有这本书
            node.value = value; // 更新 value
            return;
        }
        node = new Node(key, value); // 新书
        keyToNode.put(key, node);
        pushFront(node); // 放到最上面
        if (keyToNode.size() > capacity) { // 书太多了
            Node backNode = dummy.prev;
            keyToNode.remove(backNode.key);
            remove(backNode); // 去掉最后一本书
        }
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    private Node getNode(int key) {
        if (!keyToNode.containsKey(key)) { // 没有这本书
            return null;
        }
        Node node = keyToNode.get(key); // 有这本书
        remove(node); // 把这本书抽出来
        pushFront(node); // 放到最上面
        return node;
    }

    // 删除一个节点（抽出一本书）
    private void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
    }

    // 在链表头添加一个节点（把一本书放到最上面）
    private void pushFront(Node x) {
        x.prev = dummy;
        x.next = dummy.next;
        x.prev.next = x;
        x.next.prev = x;
    }
}


```

关于**LinkedHashMap**

```java
private final Map<Integer, Integer> cache = new LinkedHashMap<>();

public void put(int key, int value) {
    // 如果key已存在，先移除再更新，使其成为最近使用的元素
    if (cache.remove(key) != null) {
        cache.put(key, value);
        return;
    }
    
    // 如果缓存已满，移除最久未使用的元素(链表头部元素)
    if (cache.size() == capacity) {
        //使用Map的接口和collection接口快速拿到第一个节点
        Integer eldestKey = cache.keySet().iterator().next();
        cache.remove(eldestKey);
    }
    
    // 添加新元素到缓存(会放在链表末尾)
    cache.put(key, value);
}

```

![image-20260109145103862](https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202601091451800.png)

**继承LinkedHashMap**

直接继承的话可以这样用：put方法实际上不需要自己写，因为map本来就有，这里重写了LinkedHashMap的钩子函数，每次put后是否处理最老的一个。

```java
class LRUCache extends LinkedHashMap<Integer, Integer> {
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
    private final int capacity;

    public LRUCache(int capacity) {
        //第三个参数 true 表示按访问顺序排序
        super(capacity, DEFAULT_LOAD_FACTOR, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        //直接调用父类方法，存在则返回值，LinkedHashMap 会自动将访问过的元素移到末尾
        return super.getOrDefault(key, -1);
    }
	//LinkedHashMap 的钩子方法，每次 put 操作后自动调用，返回 true 时会删除最老元素（链表头部）
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}

```

### 树

**递归返回：如果是自顶向下的，可以没有返回值；如果是自底向上的，就一定要有返回值**

「在写递归函数时，可以假设递归返回的结果一定是正确的」。其实这种说法本质上就是**数学归纳法**。

#### 中序遍历非递归（线索化）

![lc94-2c.png](https://pic.leetcode.cn/1764305638-aNVMyr-lc94-2c.png)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();

        while (root != null) {
            if (root.left != null) {
                // 找 root 的前驱 pre：在中序遍历中，root 的上一个节点
                // 从 root.left 开始，一直向右走，直到走到尽头，或者遇到指向 root 的线索（回到 root 的路）
                TreeNode pre = root.left;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                }

                // root 的左子树尚未访问
                if (pre.right == null) {
                    pre.right = root; // 建立线索（回到 root 的路），相当于把 pre.right 当作栈
                    root = root.left; // 访问左子树
                    continue;
                }

                // root 的左子树访问完毕，去掉线索，恢复原样
                pre.right = null; // 注：如果调用完 inorderTraversal 不再使用这棵二叉树，这行代码可以去掉
            }

            // root 的左子树访问完毕
            ans.add(root.val); // 记录当前节点的值
            root = root.right; // 如果有右子树就访问右子树，没有就顺着线索回到指向的节点
        }

        return ans;
    }
}

```

#### 树的直径

> [543. 二叉树的直径 - 力扣（LeetCode）](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

求出来子树的最长链路长度然后拼接，全局更新max大小。

重点在于空节点处理，为-1。

```java
//最长路径长度
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
      linkLength(root);
      return max;
    }
//   求root的最长链长度
    public int linkLength(TreeNode root) {
       if (root == null) return -1;//这样如果只有一个根节点，恰好算出来链长是0，对于叶子来说，链长就是 -1+1=0
       int left =  linkLength(root.left)+1;// 左子树最大链长+1（已经考虑了如果左子树为空的情况)
       int right = linkLength(root.right)+1;
       max =  Math.max(max,left+right);//更新max，保证max拿到全局最长的直径
       return Math.max(left,right);//返回当前子树的最大链长
    }
```

#### 层次遍历java版本

两个list或者一个队列。

以前c语言还需要计算层数和加到层数到结构体，这里没那么麻烦，现成的队列然后计算每层的数量，用循环控制层数。

```java

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return List.of();
        }
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> q = new ArrayDeque<>();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            List<Integer> vals = new ArrayList<>(n); // 预分配空间
            while (n-- > 0) {//这里提前计算每一层的数量，然后仅仅遍历这几次保证只拿到这一层的
                TreeNode node = q.poll();
                vals.add(node.val);
                if (node.left != null)  q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            ans.add(vals);
        }
        return ans;
    }
}

//数组版本
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<>(); // 替代 List.of()
        }
        List<List<Integer>> ans = new ArrayList<>();//结果数组
        List<TreeNode> cur = new ArrayList<>(); //当前层节点数组
        cur.add(root);

        while (!cur.isEmpty()) {
            List<TreeNode> nxt = new ArrayList<>();
            List<Integer> vals = new ArrayList<>(cur.size());
            for (TreeNode node : cur) {
                vals.add(node.val);
                if (node.left != null)  nxt.add(node.left);
                if (node.right != null) nxt.add(node.right);
            }
            cur = nxt;
            ans.add(vals);
        }
        return ans;
    }

```

#### 给定二叉树数组构建二叉搜索树

>  [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/submissions/694022873/?envType=study-plan-v2&envId=top-100-liked)

核心在于拆分递归。中间节点为根节点，左右两侧数组都是子树。终止条件是如果数组为空就返回null。

这里要注意递归的边界，题解写法是左闭右开，这里代码是左闭右闭，因此终止条件要写left大于right。

```java

    public TreeNode sortedArrayToBST(int[] nums) {
        return buildTree(nums, 0, nums.length - 1);
    }

    public TreeNode buildTree(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = buildTree(nums, left, mid - 1);
        node.right = buildTree(nums, mid + 1, right);
        return node;
    }
```

#### 验证二叉搜索树

> [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

这里用的是前序遍历。核心在于每个节点都有一个大小区间。初始化区间是最大和最小极值，然后从验证根节点是否符合条件，再验证左右子树是否符合条件。验证左右子树的时候根据搜索树的性质传出对应的最大or最小值，另一个是原本的参数值。

```java
public boolean isValidBST(TreeNode root) {
        return isValidBST2(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public  boolean isValidBST2(TreeNode root,long min, long max) {
        if (root == null) {
            return true;
        }
        if (root.val <= min || root.val >= max) {
            return false;
        }
        return isValidBST2(root.left, min, root.val) && isValidBST2(root.right, root.val, max);

    }
```

如果用中序遍历就得记录一下pre，然后不断比较pre和根节点的值。



#### 二叉树右视图

> https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/

两个方法，简单就层序遍历记录每层最后一个节点的值，另一个方法是递归，根-右子树-左子树，并传递depth参数，知道是否新到一层，直接将根节点值加入答案中。

递归的核心是，ans.size值恰好为下一个要加的元素是第几个（第几层），传参depth与之相等时候就说明是这层的最右侧的节点，可以加入ans。

```java
//递归

    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(root, 0, ans);
        return ans;
    }

    private void dfs(TreeNode root, int depth, List<Integer> ans) {
        if (root == null) {
            return;
        }
        if (depth == ans.size()) { // 这个深度首次遇到
            ans.add(root.val);
        }
        dfs(root.right, depth + 1, ans); // 先递归右子树，保证首次遇到的一定是最右边的节点
        dfs(root.left, depth + 1, ans);
    }

//层次遍历:
public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) return ans;//这里一定要注意排除根节点为空的情况，否则下面cur.getLast会报错
        List<TreeNode> cur = new ArrayList<>();
        List<TreeNode>nxt = new ArrayList<>();
        cur.add(root);
        while (!cur.isEmpty()) {
            //每层遍历
            //这层要做的事,添加最后一个不为空的节点
            ans.add(cur.getLast().val);
            for (TreeNode node : cur) {
                if (node.left != null) {
                    nxt.add(node.left);
                }
                if (node.right != null) {
                    nxt.add(node.right);
                }
            }
            cur = nxt;
            nxt = new ArrayList<>();
        }
        return ans;
    }
```



#### 二叉树展开为链表

> [114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/submissions/694982079/?envType=study-plan-v2&envId=top-100-liked)

```java
//递归，分治，返回当前展开链表的尾结点。根节点拿到左子树的链表尾结点可以和右子树链表的根节点连接。
    public void flatten(TreeNode root) {
        dfs(root);
    }

    private TreeNode dfs(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode leftTail = dfs(root.left);
        TreeNode rightTail = dfs(root.right);
        if (leftTail != null) {
            leftTail.right = root.right; // 左子树链表 -> 右子树链表
            root.right = root.left; // 当前节点 -> 左右子树合并后的链表
            root.left = null;
        }//返回值是尾结点，这里实际分情况看尾结点是谁，有右子树尾结点就右子树尾结点，否则左，否则根
        return rightTail != null ? rightTail : leftTail != null ? leftTail : root;
    }

//递归，头插法，实际上是展开之后更新展开链表的头结点，然后按照题目的顺序进行头插（头插顺序为右-左-根），需要全局变量head。头插之后更新head
 TreeNode head;
    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.right);
        flatten(root.left);
        root.left = null;
        root.right = head;
        head = root;
    }
//笨办法，也是递归，尾插法，相比第一种得手动找尾结点
public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.left);
        flatten(root.right);
        if (root.left != null) {
            TreeNode right = root.right;
            root.right = root.left;
            root.left = null;
            TreeNode p = root.right;
            while (p.right != null) {//找尾结点
                p = p.right;
            }
            p.right = right;
        }
    }
```

#### 中序先序确定二叉树

这里注意用java的数组的复制语法就可以，左闭右开记得。

```java
  public TreeNode buildTree( int[] preorder, int[] inorder) {
        if (preorder.length==0 || inorder.length==0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        int inRootIndex = 0;
        for (int i = 0; i <= inorder.length; i++) {
            if (inorder[i] == preorder[0]) {
                inRootIndex = i;
                break;
            }
        }
        int [] leftPreOrder = Arrays.copyOfRange(preorder, 1, inRootIndex + 1);//这里是因为数值恰好相等才用的
        int [] leftInOrder = Arrays.copyOfRange(inorder, 0, inRootIndex );
        int [] rightPreOrder = Arrays.copyOfRange(preorder, inRootIndex + 1, preorder.length);
        int [] rightInOrder = Arrays.copyOfRange(inorder, inRootIndex + 1, inorder.length);
        root.left = buildTree(leftPreOrder, leftInOrder);
        root.right = buildTree(rightPreOrder,rightInOrder);
        return root;
    }
```



#### 树的路径总和III

> (https://leetcode.cn/problems/subarray-sum-equals-k/description/)  [437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/?envType=study-plan-v2&envId=top-100-liked)

这道题目应该和前缀和（560. 和为 K 的子数组）一起看，原理依旧是维护一个前缀和，然后遍历路径上的时候使用map查询，如果有就相加。并同时添加和的key到map中。但是这里用的是递归所以需要记得回退map，由于sum是递归传参不需要回退（其他分支是不影响的）

```java
class Solution {
   int res = 0;
   Map<Long, Integer> map = new HashMap<>();   
    // map用来存放当前递归分支上已经出现过的前缀和。注意节点的取值范围要使用Long

   public int pathSum(TreeNode root, int targetSum) {
       map.put(0L, 1);  // 注意先在map中放入0，不然当前缀和正好等于 targerSum 时没法被计入 res。注意这里要做 int -> Long 的类型转换
       traversal(root, targetSum, 0L); // 这里也要做 int -> Long 的类型转换
       return res;
   }

   public void traversal(TreeNode node, int targetSum, Long sum){  // 由于节点值的范围是Long，所以节点的和的类型也应该是Long
       // 参数sum表示前缀和（从根节点到当前节点的所有节点之和）
       if(node==null) return ;

       sum += node.val;
       if(map.containsKey(sum-targetSum)){
           res += map.get(sum-targetSum);
       }
       map.put(sum, map.getOrDefault(sum, 0)+1);

       traversal(node.left, targetSum, sum);   // sum不能是全局变量，而必须是递归函数的参数。否则在这里向左递归后，sum的值的变化会影响到接下来向右递归时sum的大小
       traversal(node.right, targetSum, sum);

       // 回溯。因为sum是递归函数参数，每个递归分支的sum之间互相独立，所以不用再手动回溯sum的值，只需要手动回溯map就够了
       map.put(sum, map.get(sum)-1);
   }
}
```

#### 最近公共祖先

> [236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&envId=top-100-liked)

这里推荐使用递归做法，自己原本想的是找路径然后对比（也是递归只不过需要维护路径）。

返回值的准确含义是「最近公共祖先的候选项」。对于最外层的递归调用者来说，返回值是最近公共祖先的意思。但是，在递归过程中，返回值可能是最近公共祖先，也可能是空节点（表示子树内没找到任何有用信息）、节点 p 或者节点 q（可能成为最近公共祖先，或者用来辅助判断上面的某个节点是否为最近公共祖先）。如果下面有 *q* 或者 *p*，那么当前节点就是最近公共祖先，直接返回当前节点。如果下面没有 *q* 和 *p*，那既然都没有要找的节点了，也不需要递归，直接返回当前节点。

```java
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root in (None, p, q):  # 找到 p 或 q 就不往下递归了，原因见上面答疑
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:  # 左右都找到
            return root  # 当前节点是最近公共祖先
        # 如果只有左子树找到，就返回左子树的返回值
        # 如果只有右子树找到，就返回右子树的返回值
        # 如果左右子树都没有找到，就返回 None（注意此时 right = None）
        return left or right                
//笨办法
 public TreeNode lowestCommonAncestor01(TreeNode root, TreeNode p, TreeNode q) {
        List <TreeNode> pathP = new LinkedList<>();
        List <TreeNode> pathQ = new LinkedList<>();
        dfsPath( root, p,pathP);
        dfsPath( root, q,pathQ);
        int length = Math.min(pathP.size(), pathQ.size());
        for (int i = 0; i < length ; i++) {
            if (pathP.get(i) != pathQ.get(i)) {
                return pathP.get(i-1);
            }
        }
        return pathP.get(length-1);
    }
    public void dfsPath(TreeNode root, TreeNode p,List<TreeNode> path){
        if (root == null) return ;
        path.add(root);
        if (root == p) return ;
        dfsPath(root.left,p,path);
        dfsPath(root.right,p,path);
        if (path.getLast() != p) {
            path.removeLast();//回溯
        }
    }
```

#### 最大路径之和

> [124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/submissions/695032281/?envType=study-plan-v2&envId=top-100-liked)

这道题目和前面的最大直径路径 是一样的套路，实际上我们都需要去枚举拐点，将最大的拆分成左右两边最大来进行计算。不同点在于，最大直径那里边界条件为空的时候需要判-1（这样和后面抵消），而这里需要判0（因为是和）。

- 最大最小值用Integer的最大和最小值
- 定义全局变量，和递归的返回结果不同所以单独写递归然后调用
- 注意最终递归返回值的话需要考虑和0 的关系，即当前树的最大路径值和与0的关系

```java
Integer ansMaxSum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfsMaxPathSum(root);
        return ansMaxSum;
    }
//这个递归是用来求当前树的最大的路径和（根节点出发）
    public int dfsMaxPathSum(TreeNode root) {
        if (root == null) return 0;
        int left =  dfsMaxPathSum(root.left);
        int right = dfsMaxPathSum(root.right);
        ansMaxSum = Math.max(left+right+root.val,ansMaxSum);//拐点进行判断，就可以取得全局的最大，可能不过根节点。
        return Math.max(Math.max(left,right)+root.val,0);
    }
```

### 二分搜索

在排序数组中查找元素的第一个和最后一个位置

> [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

二分搜索法和普通循环法

二分搜索需要关注区间，答案在区间外面而不在区间里。这里要求的start实际上是在left和right的外面的，最后一次循环left等于right后，left会越过right，到达区间外面的答案的位置，此时正好跳出循环。

**二分法的心法**（选一个牢记就行）

首先确定写哪种，这里我掌握了闭区间和开区间的写法。可用红蓝染色法理解，不变量是 left、right 的两侧始终符合初始定义的规则（与目标值的大小关系），全程不破坏，循环结束即得答案。

- 闭区间：left 左侧（不含 left）满足红区规则，right 右侧（不含 right）满足蓝区规则（示例：红区 < target，蓝区≥target）
  - 初始值为 0 和数组长度 - 1，覆盖整个数组
  - 转移公式为 mid+1 或 mid-1，mid 已判断需排除出未探索区间
  - 终止条件是 left>right（未探索区间为空），循环中 left≤right 持续执行；找第一个蓝区元素取 left，找最后一个红区元素取 right
- 开区间：left 及左侧满足红区规则，right 及右侧满足蓝区规则（示例：红区 < target，蓝区≥target）
  - 初始值为 - 1 和数组长度，覆盖整个数组
  - 转移公式为 mid，left/right 为开区间边界，mid 判断后可直接作为新边界
  - 终止条件是 left+1=right（区间无未探索元素），循环中 left+1<right 持续执行；找第一个蓝区元素取 right，符合开区间不变量规则

二分法函数写完，调用的时候也要记得区分：如果数组里面不包含target，那么返回值有两种情况：

- 如果不存在target可能因为全小于target而指向length位置

- 也还可能指向某一个位置就结束

因此需要对这两种情况单独判断，符合就直接返回结果。

**求末尾位置 = target+1初始位置-1**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int start = lowerBound(nums, target);
        //这里的start如果不存在target可能因为全小于target而指向length位置，也还可能指向某一个位置结束
        if (start == nums.length || nums[start] != target) {
            return new int[]{-1, -1}; // nums 中没有 target
        }
        // 如果 start 存在，那么 end 必定存在
        int end = lowerBound(nums, target + 1) - 1;
        return new int[]{start, end};
    }
    
    //闭区间写法
    // lowerBound 返回最小的满足 nums[i] >= target 的下标 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.length
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
    private int lowerBound(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            } else {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            }
        }
        // 循环结束后 left = right+1
        // 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
        // 所以 left 就是第一个 >= target 的元素下标
        return left;
    }
}

//开区间写法
public int findFirst(int []nums,int target){
        int left = -1;
        int right = nums.length;
        while(left+1<right){
            int mid  = left + (right-left)/2;
            if(nums[mid]>=target){
                right = mid;
            }else {
                left = mid;
            }
        }
        return right;
    }
```

#### 旋转数组中的最小值

##### 旋转数组特性

旋转排序数组拆分后的**左段（旋转前半段）所有元素 > 数组最后一个元素**，**右段（旋转后半段，含最小值）所有元素 ≤ 数组最后一个元素**，且两段内部均为升序。

因此用`target`和末尾元素的大小关系，能**O (1) 时间直接锁定 target 的唯一可能存在区间**，避免了对两段区间的逐一遍历，完美契合二分法的高效性要求。



<img src="C:/Users/lennert/AppData/Roaming/Typora/typora-user-images/image-20260130160710842.png" alt="image-20260130160710842" style="zoom:50%;" />

<img src="https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202601301608814.png" alt="image-20260130160833568" style="zoom:50%;" />

首先找旋转数组的最小值位置。

**闭区间表示【left，right】都没有探索。开区间表示【left+1，right-1】没有探索！终点是区间内没有探索元素，闭区间就是left>right,开区间就是left和righ相邻（因为开区间的区间内容不包含left和right端点本身）**

闭区间二分核心：不变量贯穿全程，始终保持左/右已探索区规则固定，未探索区为严格闭区间[left, right]，不破坏则循环结束得正确答案

1. 初始值规则：闭区间覆盖全部未探索区域，固定left=0、right=数组长度-1，未探索区初始为[0,n-1]，包含所有元素 
2. 循环条件规则：未探索区非空时持续循环，固定while (left <= right)，left<=right时[left,right]为非空未探索区，left>right则空、循环终止 
3. 转移公式规则：mid已探索必须排除出未探索区，仅用left=mid+1或right=mid-1，保证新未探索区[left,right]为纯未探索区域；本题nums[mid]>nums[n-1]则left=mid+1，nums[mid]≤nums[n-1]则right=mid-1 
4. 不变量核心定义：左/右已探索区规则固定，未探索区逐步缩小；本题左已探索区[0,left-1]全>nums[n-1]，右已探索区[right+1,n-1]全≤nums[n-1]，未探索区[left,right]为待判断区域，每次二分仅缩小、不破坏规则 
5. 循环终止规则：终止时未探索区为空，且left=right+1；循环结束必满足left>right，未探索区消失，所有元素划入已探索区 
6. 答案取值规则：找第一个符合蓝区规则的元素取left，left是蓝区第一个位置；本题蓝区规则为≤nums[n-1]，left指向最小值索引，返回nums[left]

```java
class Solution {
    //闭区间写法
  public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid  = left + (right-left)/2;
            if (nums[mid] > nums[nums.length - 1]) {//这里要始终和数组的末尾比较
                left = mid + 1;
            }else {
                right = mid-1;
            }
        }
        return left;//有道题目就是找旋转数组最小值，这里访问left的值就行nums[left]
    }
}
//开区间写法
public int findMin(int[] nums) {
        int left = -1;//开区间定义初始值就要在数值区间增加一个
        int right = nums.length;//开区间定义初始值就要在数值区间增加一个
        while (left +1< right) {//红蓝染色终点是left+1=right。开区间没有探索元素
            int mid  = left + (right-left)/2;
            if (nums[mid] > nums[nums.length-1]) {
                left = mid;
            }else {
                right = mid;
            }
        }
        return nums[right];
    }
```

#### 搜索旋转数组

这里应用了之前写的代码，首先先找到旋转数组中的最小的位置。然后，比较target和末尾元素值，确定在哪段进行二分，其次，写一个简单的二分法分别调用两次在两个区间中进行比较。

这里用**比较target和末尾元素值**来确定在哪个区间用二分很巧妙，这样如果minidx为0或者1，一定存在有一个区间是空区间，但是二分法中有严格的区间机制，空区间会自动结束的！（**二分法的严格区间机制会让空区间自动结束循环**，无需额外处理 —— 这正是闭区间（及开区间）二分法的天然优势，也是代码无需冗余边界判断的根本原因。）

```java


//全部开区间写法（推荐）
public int findMinIndex(int[] nums) {
        int left = -1;
        int right = nums.length;
        while (left +1< right) {
            int mid  = left + (right-left)/2;
            if (nums[mid] > nums[nums.length-1]) {
                left = mid;
            }else {
                right = mid;
            }
        }
        return right;
    }
    public int search(int[] nums, int target) {
        int min = findMin(nums);
        if(target > nums[nums.length-1]){
            //target在第一段
           int leftRes = lowerBound(nums,target,-1,min);
            if (leftRes == min || nums[leftRes] != target) {
                return -1;
            }
            return leftRes;
        }else  {
            int rightRes = lowerBound(nums,target,min-1,nums.length);
            if (rightRes == nums.length || nums[rightRes] != target) {
                return -1;
            }
            return rightRes;
        }
    }
    //开区间写法
    public int lowerBound(int []nums, int target,int left,int right) {
        while (left+1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }



//全部闭区间写法
class Solution {
    // 闭区间找旋转数组最小值的索引（核心：找第一个≤nums[n-1]的位置）
    public int findMinIndex(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[nums.length - 1]) {
                left = mid + 1; // mid在左段，收缩左边界
            } else {
                right = mid - 1; // mid在右段，收缩右边界
            }
        }
        return left; // 循环结束left指向最小值索引
    }

    public int search(int[] nums, int target) {
        int minIdx = findMinIndex(nums);
        int n = nums.length;
        if (target > nums[n - 1]) {
            // target在左段[0, minIdx-1]，闭区间二分查找
            int res = lowerBoundClose(nums, target, 0, minIdx - 1);
            return (res <= minIdx - 1 && nums[res] == target) ? res : -1;
        } else {
            // target在右段[minIdx, n-1]，闭区间二分查找
            int res = lowerBoundClose(nums, target, minIdx, n - 1);
            return (res < n && nums[res] == target) ? res : -1;
        }
    }

    // 闭区间版lowerBound：在[left, right]范围内找第一个≥target的索引
    // 闭区间规则：初始[L,R]、循环left<=right、转移mid±1、返回left
    public int lowerBoundClose(int[] nums, int target, int L, int R) {
        int left = L;
        int right = R;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1; // 目标在左半段，收缩右边界
            } else {
                left = mid + 1; // 目标在右半段，收缩左边界
            }
        }
        return left; // 循环结束left指向第一个≥target的位置
    }
}
```

#### 寻找两个有序数组的中位数(hard,最难了直接背)

不合并数组，通过**划分数组**找中位数：将两个有序数组合法划分为左右两半区，左半区总元素数≥右半区，且左半区所有数≤右半区所有数，此时**奇数取左半区最大值，偶数取左右半区最值平均值**。

**合法划分要求**

1. 左半区 = nums1 前 i 个 + nums2 前 j 个；右半区 = nums1 剩余 + nums2 剩余；
2. 核心公式绑定 i/j：`j = (m+n+1)/2 - i`，保证左半区元素数符合中位数要求；
3. 合法条件：`a[i] ≤ b[j+1] && a[i+1] > b[j]`，保证左右半区有序。

- 步骤 1：短数组前置
  - 逻辑：将更短的数组设为 nums1，长数组为 nums2，减少后续枚举次数，规避边界问题。

- 步骤 2：构建哨兵数组
  - 逻辑：为两原数组各建新数组（长度 = 原长 + 2），首位置负无穷、末位置正无穷作哨兵，避免划分点在首尾时越界；原数组元素拷贝至新数组 1~ 原长度索引处。

- 步骤 3：初始化划分点
  - 逻辑：i 是 nums1 放入左半区的元素数，j 是 nums2 放入左半区的元素数；用公式`j=(m+n+1)/2 -i`（m、n 为两原数组长度）绑定 i 和 j，保证左半区元素数符合中位数取值要求。

- 步骤 4：枚举找合法划分
  - 逻辑：i 从 0 开始枚举，不满足合法条件则 i++、j--；合法条件为`a[i] ≤ b[j+1] 且 a[i+1] > b[j]`（a、b 为哨兵数组），满足则进入中位数计算。

- 步骤 5：计算并返回中位数
  - 逻辑：取 a、b 左半区最后一个数的最大值，作为整体左半区全局最大值；取 a、b 右半区第一个数的最小值，作为整体右半区全局最小值；总长度奇数返回左半区最大值，偶数返回左右半区最值的平均值。

```java
//寻找两个正序数组的中位数-hard，直接背吧
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            int [] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        int m = nums1.length;
        int n = nums2.length;
        int []a = new int[m+2];
        int []b = new int[n+2];
        a[0] = b[0] = Integer.MIN_VALUE;
        a[m+1] = b[n+1] = Integer.MAX_VALUE;
       System.arraycopy(nums1, 0, a, 1, m);
       System.arraycopy(nums2, 0, b, 1, n);
       int i = 0;
       int j = (m+n+1)/2-i;
       while(true){
           if (a[i+1]>b[j] && a[i]<=b[j+1] ) {
               //找到了
               int max1 = Math.max(a[i], b[j]);
               int min2 = Math.min(a[i + 1], b[j + 1]);
               return (m + n) % 2 > 0 ? max1 : (max1 + min2) / 2.0;
           }
           i++;
           j--;
       }
    }
```

