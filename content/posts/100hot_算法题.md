+++
date = '2025-12-09'
draft = false
title = 'leecode Hot100 学习记录'

tags = ["前缀和"]

categories = ["算法题"]

+++





### 前缀和

> **不单调数组求任意子数组和**

前缀和概念和数列前n项和的概念很像，但是不包含最后一项（左闭右开），模版来自[303. 区域和检索 - 数组不可变 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-immutable/)

主要特点是，通过定义一个数组前缀和，就可以只需要O(1)复杂度求出任意一个子数组的和结果。

```java
//leecode303.区域和检索：计算前缀和的模版实现

public class NumArray {
    private final int [] s;
    public NumArray(int [] nums) {
        s = new int [nums.length+1];
        for (int i = 0; i <nums.length; i++) {
            s[i+1] =s[i] + nums[i];//默认定义了s【0】为0
        }
    }
    public int sumRange(int left, int right) {
        return s[right+1]-s[left];
    }
}
```

应用这个定义可以做[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

**Q：为什么要用前缀和？**

A：因为这个待求的数组是**不单调**的。使用前缀和定义的数据结构，**两个值相减可以求出来任意一个子数组的和**。滑动窗口需要满足单调性，当右端点元素进入窗口时，窗口元素和是不能减少的。本题 nums 包含负数，当负数进入窗口时，窗口左端点该往哪个方向移动？无法确定。如果没有负数的话，则可以用滑动窗口。

于是转换成 **s[j]-s[i] = k** 这样的问题。可以看成是两数之和的变种。

**s[j] = k + s[i]  => s[right]-k = s[left]** , 然后使用哈希表，快速定位是否存在，存在了就说明加1，最后合并所有的值。这里注意必须要用sj-k而不是si+k。这是因为，我们需要进行遍历来填充哈希表，在遍历的过程中去寻找符合条件的i与j。由于j大于i，也就是说，我们只有先知道了j才能知道i。遍历过程是只能先知道遍历到的元素的值，是只能给遍历过的元素key赋值value的。因此，我们只能求得si。因为si表示就是在当前元素sj之前的元素。

> **两数之和变体：选择更大的那个值与target计算，求之前遍历过的是否存在小的那个值。**

```java
public int subarraySum(int[] nums, int k) {
        int [] s = new int[nums.length+1];
        for (int i=0;i<nums.length;i++){
            s[i+1] =  s[i]+nums[i];
        }
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <s.length ; i++) {
            ans += map.getOrDefault(s[i]-k,0);//查询已有的哈希表
            map.put(s[i],map.getOrDefault(s[i],0)+1);//创建前缀和的值的哈希表元素
        }
        return ans;
    }
```

同样的问题可以解决：[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

实际上这个需要计算最大数组和，多考虑一步就是如何得到最大数组和，s[i] - min（s[k])。我们依旧遍历一次前缀数组，但是我们记录前缀数组最小的部分在哪里，然后用当前的和减去之前的最小的和，可以求得当前最大的值。遍历一轮不停更新最小的和与最大的值，就可以得到最终的结果了。注意：min需要从s[0]开始，而这道题目必须要先比较最大值，再更新最小和，否则会将只有一个元素的数组误求成0。

```java
public int maxSubArray(int[] nums) {
           int []sum =  new int[nums.length+1];
           for (int i = 0; i < nums.length; i++) {
                    sum[i+1] = sum[i] + nums[i];
           }//求出前缀和数组
           int min = 0;
           int maxVal = Integer.MIN_VALUE;
           for (int i = 1; i < sum.length; i++) {
               if (sum[i]-min > maxVal){
                   maxVal = sum[i]-min;
               }
               if (sum[i] < min){
                   min = sum[i];
               }
           }
           return maxVal;
    }
```





### 滑动窗口求最大值

使用方法：单调队列

>  **“及时去除无用数据，保证双端队列有序”**

> [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/solutions/2499715/shi-pin-yi-ge-shi-pin-miao-dong-dan-diao-ezj6/?envType=study-plan-v2&envId=top-100-liked)

模拟滑动窗口的过程，发现：如果新加入的比前面的大，那么很可能是窗口最大值。而前面已经加入的肯定不可能是最大值（要比更大的先脱离窗口）；而新加入的比前面的小的时候，新加入的元素仍然有可能变成最大值（当后来的逗比新加入的小）

所以最后我们希望记录下最可能成为最大值的元素，而去掉不可能成为最大值的元素，构成了一个单调的变动的集合。最终我们需要的数据结构是左出右进/右出的结构，因此使用的是双端队列。

由于队列维护的结构都是单调的，因此这个方法也叫做**单调队列**。

> 说实在的，理解这道题突然有点破防：后来进滑动窗口的一定比窗口里面的更加**’‘年轻‘’**，新来的寿命比你长，**价值**还比你大，凭什么还留着你个老登。你不可能成为最大的那个了。如果新来的没你有价值，其实你还是有可能成为最大的地位的。退位也是以后的事。

具体代码如下：每个元素只会进一次队列出一次队列，虽然看着是两个循环，但是时间复杂度是O（n），空间复杂度是O（k）

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length-k+1];
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++) {
//           进
            while (!q.isEmpty() && nums[q.getLast()] < nums[i] ) {
                //后来者更大，需要删除已有的最新的，保证只留下最可能成为最大值的,可能要去掉多个所以用的是while而不是if
                q.removeLast();
            }
            q.addLast(i);
//            出，能出or该出就出
            int left = i-k+1;
            if (left >q.getFirst() ) {
                q.removeFirst();
            }
//            记录元素
            if (left>=0){
                ans[left]=nums[q.getFirst()];
            }
        }
        return ans;
    }
}
```

其他单调队列题目：

- [ ]  绝对差不超过限制的最长连续子数组 https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ 
- [ ] 预算内的最多机器人数目 https://leetcode.cn/problems/maximum-number-of-robots-within-budget/
- [ ] 和至少为 K 的最短子数组 https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/
- [ ] 满足不等式的最大值 https://leetcode.cn/problems/max-value-of-equation/ 
- [ ]  跳跃游戏 VI https://leetcode.cn/problems/jump-game-vi/ 
- [ ] 购买水果需要的最少金币数 https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/



### 覆盖子串类问题

使用方法：数组记录每个字母出现次数，然后比较。

今天自己写出来的第一个`hard`题目:smile:（虽然判断函数的逻辑有问题抄的灵神的，但是主要逻辑都是自己一气呵成的！大大的进步！）

> [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)

思路：这类题目给定一个长的串s，给定一个短串t。核心在于如何判断是否s的子串包含t。这个题目要求的是只要**覆盖**了就行。如abvc覆盖了abc。核心在于写判断什么时候覆盖的逻辑。需要自定义一个函数进行判断。主要逻辑就是滑动窗口来收集所有的覆盖t的子串，然后记录到哈希表里面最后拿出最小的那个就行。

**时间复杂度：O(52 \* n) = O(n)**，其中n是字符串s的长度

1. **isCovered方法**：每次调用需要遍历52个字符（26个大写字母 + 26个小写字母），时间复杂度O(52)
2. **minWindow方法**：
   - 初始化：O(|t|)，统计t中字符频率
   - 双指针遍历：O(n)，n是s的长度
   - 每次移动指针时可能调用isCovered：最坏情况下O(52*n)

具体个人代码如下：

```java
class Solution {
   private boolean isCovered(int[] cntS, int[] cntT) {
        for (int i = 'A'; i <= 'Z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;//反着来快，有一个反例就不行
            }
        }
        for (int i = 'a'; i <= 'z'; i++) {
            if (cntS[i] < cntT[i]) {
                return false;
            }
        }
        return true;
    }

      public String minWindow(String s, String t) {
        int [] countT = new int[128];
        int [] countS = new int[128];
        Map<Integer,String> map = new HashMap<>();
        int min = Integer.MAX_VALUE;
        for (int i=0;i<t.length();i++){
            countT[t.charAt(i)]++;
        }//统计出来每个字母的频率
        int left = 0;
        int right = 0;
        while (right < s.length()){
            countS[s.charAt(right)]++;
            right++;
            if (isCovered(countS, countT)){
                while(left<right && isCovered(countS, countT)){
                    countS[s.charAt(left)]--;
                    left++;//这个left一定会加，好处就是实际上最后的left一定是新的滑动窗口起点，继续找子串，而不是停留在原地陷入死循环。
                }
                map.put(right-left+1,s.substring(left-1,right)) ;//这里得注意，left一定要减一，right前面也是加了之后的所以直接用就行。substring是左闭右开，这里不需要用right+1；
                min = Math.min(min,right-left+1);
            }
        }
        if (map.containsKey(min)){
            return map.get(min);
        }
    return "";
    }
}
```



### 数组

#### 区间合并问题

使用方法：排序

> [56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-100-liked)

合并区间的关键在于，必须先都按照左端点进行排序，这样就可以仅关注右边端点。一旦出现下一个左端点是大于当前的右端的值，那么当前的区间一定就是固定的结果区间了。因为排序之后不存在后面的其他区间左端点比下一个左端点小。

两个关键代码：写排序的比较器；写比较过程的分支结构

关于比较器：

`Comparator` 是 Java 中的一个函数式接口，位于 `java.util` 包下。它定义了一个用于比较两个对象的方法 `compare`，该方法接受两个参数，并返回一个整数值。返回值的含义如下：

- 如果返回值小于 0，表示第一个参数小于第二个参数。
- 如果返回值等于 0，表示两个参数相等。
- 如果返回值大于 0，表示第一个参数大于第二个参数。

也就是说，如果写（a,b）->return a - b; 就肯定是正序了，因为如果a大，那么返回的就是正数，而a实际就会排在后面了。反之，如果写成return b-a，那么就是倒序，因为b大，返回正数，让a排在了b的前面。也就是说，返回值的符号实际上表示了第一个参数和第二个参数的关系，谁小谁在前，谁大谁靠后，然后才看出来是不是正序/倒序。

具体代码如下：

```java
 public int[][] merge(int[][] intervals) {
        List<int []> ans = new ArrayList<>();
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);//正序排序左端点
        for (int i = 0; i < intervals.length; i++) {
            if (!ans.isEmpty() && ans.getLast()[1]>=intervals[i][0]){
                ans.getLast()[1]=Math.max(ans.getLast()[1],intervals[i][1]);
            }else  {
                ans.addLast(intervals[i]);
            } 
        }
        return ans.toArray(new int[ans.size()][]);
    }
```

#### 轮转数组

关键在于两个注意点：

一是要将k取模，大于数组长度的k相当于先转一圈（没变）再转几个，需要防止数组越界；

二是了解java特性，java没有指针，传递的是数组的引用。在Java中，数组是对象，所以当数组作为参数传递时，传递的是**引用（内存地址）**，而不是数组本身的副本。

```java
class Solution {
    public void ratateUtil(int [] nums,int start,int end){
        int l = start;
        int r = end;
        while( l < r){
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }

    public void rotate(int[] nums, int k) {
            k = k % nums.length;
            ratateUtil(nums,0,nums.length-1);
            ratateUtil(nums,0,k-1);
            ratateUtil(nums,k,nums.length-1);
        
        
    }
}
```

####  求除自身外数组乘积

题目[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

关键点：这道题目不能用除法，要模仿前缀和的方法，实际上可以用前缀乘积和后缀乘积来做。直接用前缀*后缀就可以了。

```java
//普通方法
public int[] productExceptSelf(int[] nums) {
//        先计算前缀后缀
        int [] pre =  new int[nums.length+1];
        pre[0] = 1;
        int [] suf =  new int[nums.length+1];
        suf[nums.length-1] =1;//注意前缀和后缀的初始化都是基于源数组的起始和末尾的，乘积所以用1初始化
        for (int i = 1; i <=nums.length; i++){
            pre[i] = pre[i-1]*nums[i-1];
        }
        for (int i = nums.length-2; i >=0; i--){
            suf[i] = suf[i+1]*nums[i+1];
        }
    
        int []res =  new int[nums.length];
        for(int i =0;i<nums.length;i++){
            res[i] = pre[i]*suf[i];
        }
        return res;
    }



//优化空间复杂度的方法
public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] suf = new int[n];
        suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        int pre = 1;
        for (int i = 0; i < n; i++) {
            // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中
            suf[i] *= pre;
            pre *= nums[i];
        }

        return suf;
    }


```

#### 缺失的第一个正数

题目：[41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/submissions/684702448/?envType=study-plan-v2&envId=top-100-liked)

注意：这道题目需要时间复杂度为O(n)，空间复杂度为O(1)。所以核心在于交换，我们的排查方式就是让每个数归位到正确的位置上，然后从头开始找第一个不在位置的正数；如果找不到就是n+1。

- 缺失的第一个正数表明一定是范围在1-n，不可能更大，作为交换判断的条件。这种场景下的交换排序的时间复杂度依旧是O（n）
- 一直换到当前的位置变成正确的值。

```java
 public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            //给数组的每个数找他们应该在的位置，发现不对就交换。让原本的数组从1开始。所以这里用的是=nums[nums[i]-1]
            while(nums[i]>=1 && nums[i]<=nums.length && nums[i]!=nums[nums[i]-1]){
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
            }
        }
     //因此这里的判断是i+1，因为当前格子实际数组是1-n的顺序，是比索引大一。
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i+1) {
                return i+1;
            }
        }
        return nums.length+1;
    }
```

### 矩阵

#### 螺旋矩阵

重点在于使用一个二维数组当做下一步的方向上的增减，并提前预判下一步是否超界或者遍历过，根据条件转向。

![image-20251220192703470](https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202512201927061.png)

```java
public List<Integer> spiralOrder(int[][] matrix) {
        int m =  matrix.length;
        int n = matrix[0].length;
        List<Integer> ans = new ArrayList<>();
        int[][] copy = new int[m][n];//防止更改原本的数组
        for (int i = 0; i < matrix.length; i++) {
            copy[i] = Arrays.copyOf(matrix[i], matrix[i].length);
        }
        int [][]DIRECTION = new int [][]{{0,1},{1,0},{0,-1},{-1,0}};
        int i=0,j=0;
        int di = 0;//表示现在是哪个方向
        for (int k = 0; k < n*m; k++) {
            ans.add(matrix[i][j]);
            copy[i][j] = Integer.MAX_VALUE;
            int x = i+DIRECTION[di][0];
            int y = j+DIRECTION[di][1];
            if (x<0 || x>=m || y<0 || y>=n || copy[x][y]==Integer.MAX_VALUE) {
                di = (di+1) % 4;//该转向了
            }
            i = i+DIRECTION[di][0];
            j = j+DIRECTION[di][1];
        }

        return ans;
    }
```

#### 顺时针旋转矩阵

> [48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)

代码很简单，一次转置+一次横对称。但是原理需要理解：

**顺时针旋转90°的具体实现**

对于顺时针旋转90°：

- θ = 90°，所以两条对称轴夹角应为45°
- 具体操作：
  1. 先关于**主对角线**翻转（左上到右下的对角线）
  2. 再关于**垂直中轴**翻转（矩阵的垂直中线）

![image-20251220195528875](https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202512201955256.png)

```java
   public void rotate(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < i; j++) {//转置只对对角线下的元素操作。
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length/2; j++) {
                int temp  = matrix[i][j];
                matrix[i][j] = matrix[i][matrix[i].length-j-1];//对称交换
                matrix[i][matrix[i].length-j-1] = temp;
            }
        }
    }
```

#### 二维有序矩阵查找

笨办法就是每行用个二分法。

记得用优化后的写法：int mid = left + (right-left)/2;

灵神的写法是，每次只看右上角的：大就删列，小就删行。

时间复杂度O（m+n）

```java
public boolean searchMatrix(int[][] matrix, int target) {
       int i = 0;
       int j = matrix[0].length-1;
       while (i < matrix.length && j >= 0){
           if (matrix[i][j] == target){
               return true;
           }else if (matrix[i][j] > target){
               j--;
           }else {
               i++;
           }
       }
        return false;
    }
```

### 链表

#### 相交链表

其实这个题我会，但是灵神的代码实在太牛逼了，记一下

**这个代码是寻找两个链表的交点。**

原理：
两个指针分别从两个链表头开始，同步前进。当一个指针到达链表末尾时，它跳到另一个链表的头继续前进。这样两个指针走过的总路程相同，如果有交点，它们最终会在交点处相遇。

```java
class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        while (p != q) {
            p = p != null ? p.next : headB;
            q = q != null ? q.next : headA;
        }
        return p;
    }
}
```



#### 两数相加

> [2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked)

主要是为了看下简便的写法：

1. **更优雅的边界处理**：循环条件`while (l1 != null || l2 != null || carry != 0)`确保所有情况都被处理，包括最后可能的进位。
2. **统一的节点创建**：不再需要多个if-else分支来决定是否创建新节点，而是统一创建新节点并更新carry值。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0); // 虚拟头节点
        ListNode curr = dummy;
        int carry = 0;
        
        while (l1 != null || l2 != null || carry != 0) {//概括三种情况
            int x = (l1 != null) ? l1.val : 0;//第一条链表的值
            int y = (l2 != null) ? l2.val : 0;//第二条链表的值
            int sum = carry + x + y;//暂时的和
            
            carry = sum / 10;//是否进位
            curr.next = new ListNode(sum % 10);//结果
            curr = curr.next;//下一个
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        return dummy.next;
    }
}

```

#### 删除链表节点

> [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked)

换句话说，**如果遇到需要删除头节点的题目，添加哨兵节点可以简化代码逻辑**，请记住这个技巧。

>  加了一个头结点之后，删除时候就不需要额外讨论删除头结点的问题，如果真要讨论就看fast的状态，根据fast的位置判断是否删除头。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode pHead = new ListNode(0);
        pHead.next = head;
        ListNode fast = pHead;
        ListNode slow = pHead;
        int count = 0;
        while(fast!=null&&count<n){
            fast = fast.next;
            count++;
        }
        while(fast!=null && fast.next!=null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;

        return pHead.next;
    }
```

#### 反转链表II

```java
//反转链表2-片段反转  需要哨兵+pre /cur/next三个指针保证当前指向前面的，最后连接原链表和反转后的尾巴和头部。返回哨兵下一个
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new  ListNode(0) ;
        dummy.next = head;
        ListNode p = dummy;
        int count = 0;
        while (count < left-1) {
            p = p.next;
            count++;
        }//p在left前一个，从这里开始反转
        ListNode pre = null;
        ListNode cur = p.next;
        while (count < right) {//遍历最后一次结束cur是反转的下一个，pre时反转的最后一个
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
            count++;
        }
        p.next.next = cur;
        p.next = pre;
        return dummy.next;
    }
```

k个反转链表同上道理，多统计一次长度，加更新p0

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 统计节点个数
        int n = 0;
        for (ListNode cur = head; cur != null; cur = cur.next) {
            n++;
        }

        ListNode dummy = new ListNode(0, head);
        ListNode p0 = dummy;
        ListNode pre = null;
        ListNode cur = head;

        // k 个一组处理
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; i++) { // 同 92 题
                ListNode nxt = cur.next;
                cur.next = pre; // 每次循环只修改一个 next，方便大家理解
                pre = cur;
                cur = nxt;
            }

            // 见视频
            ListNode nxt = p0.next;
            p0.next.next = cur;
            p0.next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
}

作者：灵茶山艾府
链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/1992228/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### 链表排序

使用分治思想，递归执行 分成两个链表、两个链表排序、合并有序链表。

需要注意的是，这里的分成两个链表一定要保证能断开，可以用两个节点长度的链表进行实验，进行分割。

要么是在取得中间节点时候多加一个指针pre，然后找到slow之后，pre操作断开。（推荐）

要么就获取前半个末端然后手动断开。代码用的第一种，更加简便。

```java
class Solution {
    public ListNode sortList(ListNode head) {
        // 如果链表为空或者只有一个节点，无需排序
        if (head == null || head.next == null) {
            return head;
        }
        // 找到中间节点 head2，并断开 head2 与其前一个节点的连接
        // 比如 head=[4,2,1,3]，那么 middleNode 调用结束后 head=[4,2] head2=[1,3]
        ListNode head2 = middleNode(head);
        // 分治
        head = sortList(head);
        head2 = sortList(head2);
        // 合并
        return mergeTwoLists(head, head2);
    }

    // 876. 链表的中间结点（快慢指针）
    private ListNode middleNode(ListNode head) {
        ListNode pre = head;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            pre = slow; // 记录 slow 的前一个节点
            slow = slow.next;
            fast = fast.next.next;
        }
        pre.next = null; // 断开 slow 的前一个节点和 slow 的连接
        return slow;
    }

    // 21. 合并两个有序链表（双指针）
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(); // 用哨兵节点简化代码逻辑
        ListNode cur = dummy; // cur 指向新链表的末尾
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1; // 把 list1 加到新链表中
                list1 = list1.next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur.next = list2; // 把 list2 加到新链表中
                list2 = list2.next;
            }
            cur = cur.next;
        }
        cur.next = list1 != null ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }
}
```

#### 多个有序链表合并

这道题目笨办法可以循环逐个进行两两合并的方法，但是更好的办法在于，所有的链表都是有序的可以进行使用堆排序，用优先队列不断维护一个最小节点的堆。每次仅加入头结点（头结点都是最小的）

```java
public ListNode mergeKLists(ListNode[] lists) {
    // 创建优先队列（最小堆），按照节点值升序排列
    PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
    // 将每个链表的头节点（非空）加入优先队列
    for (ListNode node : lists) {
        if (node != null) {
            pq.offer(node);
        }
    } 
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;
    // 当优先队列不为空时，循环处理
    while (!pq.isEmpty()) {
        // 弹出堆顶元素（当前所有链表头节点中的最小值）
        ListNode node = pq.poll();
        // 将最小节点连接到结果链表中
        cur.next = node;
        cur = cur.next;      
        // 如果该节点有后续节点，将其加入优先队列
        if (node.next != null) {
            pq.offer(node.next);
        }
    } 
    return dummy.next;
}
```

#### LRU 缓存

> [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)

这道题目如果是纯实现要用linkedhashmap，但是算法面试需要自己实现双链表。借用灵神的图和代码。

![图解 LRU](https://pic.leetcode.cn/1696039105-PSyHej-146-3-c.png)

问：需要几个哨兵节点？

答：一个就够了。一开始哨兵节点 dummy 的 prev 和 next 都指向 dummy。随着节点的插入，dummy 的 next 指向链表的第一个节点（最上面的书），prev 指向链表的最后一个节点（最下面的书）。

问：为什么节点要把 key 也存下来？

答：在删除链表末尾节点时，也要删除哈希表中的记录，这需要知道末尾节点的 key。

```java
class LRUCache {
    private static class Node {
        int key, value;
        Node prev, next;

        Node(int k, int v) {
            key = k;
            value = v;
        }
    }

    private final int capacity;
    private final Node dummy = new Node(0, 0); // 哨兵节点
    private final Map<Integer, Node> keyToNode = new HashMap<>();

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummy.prev = dummy;
        dummy.next = dummy;
    }

    public int get(int key) {
        Node node = getNode(key); // getNode 会把对应节点移到链表头部
        return node != null ? node.value : -1;
    }

    public void put(int key, int value) {
        Node node = getNode(key); // getNode 会把对应节点移到链表头部
        if (node != null) { // 有这本书
            node.value = value; // 更新 value
            return;
        }
        node = new Node(key, value); // 新书
        keyToNode.put(key, node);
        pushFront(node); // 放到最上面
        if (keyToNode.size() > capacity) { // 书太多了
            Node backNode = dummy.prev;
            keyToNode.remove(backNode.key);
            remove(backNode); // 去掉最后一本书
        }
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    private Node getNode(int key) {
        if (!keyToNode.containsKey(key)) { // 没有这本书
            return null;
        }
        Node node = keyToNode.get(key); // 有这本书
        remove(node); // 把这本书抽出来
        pushFront(node); // 放到最上面
        return node;
    }

    // 删除一个节点（抽出一本书）
    private void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
    }

    // 在链表头添加一个节点（把一本书放到最上面）
    private void pushFront(Node x) {
        x.prev = dummy;
        x.next = dummy.next;
        x.prev.next = x;
        x.next.prev = x;
    }
}


```

关于**LinkedHashMap**

```java
private final Map<Integer, Integer> cache = new LinkedHashMap<>();

public void put(int key, int value) {
    // 如果key已存在，先移除再更新，使其成为最近使用的元素
    if (cache.remove(key) != null) {
        cache.put(key, value);
        return;
    }
    
    // 如果缓存已满，移除最久未使用的元素(链表头部元素)
    if (cache.size() == capacity) {
        //使用Map的接口和collection接口快速拿到第一个节点
        Integer eldestKey = cache.keySet().iterator().next();
        cache.remove(eldestKey);
    }
    
    // 添加新元素到缓存(会放在链表末尾)
    cache.put(key, value);
}

```

![image-20260109145103862](https://picgo-lenblog.oss-cn-beijing.aliyuncs.com/lenblog/202601091451800.png)

**继承LinkedHashMap**

直接继承的话可以这样用：put方法实际上不需要自己写，因为map本来就有，这里重写了LinkedHashMap的钩子函数，每次put后是否处理最老的一个。

```java
class LRUCache extends LinkedHashMap<Integer, Integer> {
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
    private final int capacity;

    public LRUCache(int capacity) {
        //第三个参数 true 表示按访问顺序排序
        super(capacity, DEFAULT_LOAD_FACTOR, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        //直接调用父类方法，存在则返回值，LinkedHashMap 会自动将访问过的元素移到末尾
        return super.getOrDefault(key, -1);
    }
	//LinkedHashMap 的钩子方法，每次 put 操作后自动调用，返回 true 时会删除最老元素（链表头部）
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}

```

### 树

「在写递归函数时，可以假设递归返回的结果一定是正确的」。其实这种说法本质上就是**数学归纳法**。

#### 中序遍历非递归（线索化）

![lc94-2c.png](https://pic.leetcode.cn/1764305638-aNVMyr-lc94-2c.png)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();

        while (root != null) {
            if (root.left != null) {
                // 找 root 的前驱 pre：在中序遍历中，root 的上一个节点
                // 从 root.left 开始，一直向右走，直到走到尽头，或者遇到指向 root 的线索（回到 root 的路）
                TreeNode pre = root.left;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                }

                // root 的左子树尚未访问
                if (pre.right == null) {
                    pre.right = root; // 建立线索（回到 root 的路），相当于把 pre.right 当作栈
                    root = root.left; // 访问左子树
                    continue;
                }

                // root 的左子树访问完毕，去掉线索，恢复原样
                pre.right = null; // 注：如果调用完 inorderTraversal 不再使用这棵二叉树，这行代码可以去掉
            }

            // root 的左子树访问完毕
            ans.add(root.val); // 记录当前节点的值
            root = root.right; // 如果有右子树就访问右子树，没有就顺着线索回到指向的节点
        }

        return ans;
    }
}

```

#### 树的直径

> [543. 二叉树的直径 - 力扣（LeetCode）](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

求出来子树的最长链路长度然后拼接，全局更新max大小。

重点在于空节点处理，为-1。

```java
//最长路径长度
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
      linkLength(root);
      return max;
    }
//   求root的最长链长度
    public int linkLength(TreeNode root) {
       if (root == null) return -1;//这样如果只有一个根节点，恰好算出来链长是0，对于叶子来说，链长就是 -1+1=0
       int left =  linkLength(root.left)+1;// 左子树最大链长+1（已经考虑了如果左子树为空的情况)
       int right = linkLength(root.right)+1;
       max =  Math.max(max,left+right);//更新max，保证max拿到全局最长的直径
       return Math.max(left,right);//返回当前子树的最大链长
    }
```

#### 层次遍历java版本

两个list或者一个队列。

以前c语言还需要计算层数和加到层数到结构体，这里没那么麻烦，现成的队列然后计算每层的数量，用循环控制层数。

```java

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return List.of();
        }
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> q = new ArrayDeque<>();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            List<Integer> vals = new ArrayList<>(n); // 预分配空间
            while (n-- > 0) {//这里提前计算每一层的数量，然后仅仅遍历这几次保证只拿到这一层的
                TreeNode node = q.poll();
                vals.add(node.val);
                if (node.left != null)  q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            ans.add(vals);
        }
        return ans;
    }
}

//数组版本
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<>(); // 替代 List.of()
        }
        List<List<Integer>> ans = new ArrayList<>();//结果数组
        List<TreeNode> cur = new ArrayList<>(); //当前层节点数组
        cur.add(root);

        while (!cur.isEmpty()) {
            List<TreeNode> nxt = new ArrayList<>();
            List<Integer> vals = new ArrayList<>(cur.size());
            for (TreeNode node : cur) {
                vals.add(node.val);
                if (node.left != null)  nxt.add(node.left);
                if (node.right != null) nxt.add(node.right);
            }
            cur = nxt;
            ans.add(vals);
        }
        return ans;
    }

```

#### 给定二叉树数组构建二叉搜索树

>  [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/submissions/694022873/?envType=study-plan-v2&envId=top-100-liked)

核心在于拆分递归。中间节点为根节点，左右两侧数组都是子树。终止条件是如果数组为空就返回null。

这里要注意递归的边界，题解写法是左闭右开，这里代码是左闭右闭，因此终止条件要写left大于right。

```java

    public TreeNode sortedArrayToBST(int[] nums) {
        return buildTree(nums, 0, nums.length - 1);
    }

    public TreeNode buildTree(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = buildTree(nums, left, mid - 1);
        node.right = buildTree(nums, mid + 1, right);
        return node;
    }
```

#### 验证二叉搜索树

> [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

这里用的是前序遍历。核心在于每个节点都有一个大小区间。初始化区间是最大和最小极值，然后从验证根节点是否符合条件，再验证左右子树是否符合条件。验证左右子树的时候根据搜索树的性质传出对应的最大or最小值，另一个是原本的参数值。

```java
public boolean isValidBST(TreeNode root) {
        return isValidBST2(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public  boolean isValidBST2(TreeNode root,long min, long max) {
        if (root == null) {
            return true;
        }
        if (root.val <= min || root.val >= max) {
            return false;
        }
        return isValidBST2(root.left, min, root.val) && isValidBST2(root.right, root.val, max);

    }
```

如果用中序遍历就得记录一下pre，然后不断比较pre和根节点的值。

