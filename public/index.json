[{"categories":["故障排查"],"content":"清理linux服务器根目录空间 现象：代码无法复制到新文件，创建的新文件无法正常写入内容，大小保存后为0kb。无法上传新的文件。这说明根目录磁盘空间满了。 ","date":"2026-01-07","objectID":"/posts/%E6%8E%92%E6%9F%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98/:1:0","tags":["linux","清理空间"],"title":"排查linux服务器根目录空间满的问题","uri":"/posts/%E6%8E%92%E6%9F%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["故障排查"],"content":"排查步骤 检查是否确实根目录空间满： ssh连接工具如MobaXterm可以设置右下角显示内存空间信息，随时进行观察。 使用命令先查看根分区整体使用情况 df -h /\r输出重点看 Use%（使用率）和 Avail（可用空间），确认是否真的满了（Use%≥95%）。 这是根目录的使用情况。 为什么/dev/nvme0n1p3 是根目录？ Linux 中所有硬件设备都以文件形式存在于 /dev 目录下，这个名称是 NVMe 固态硬盘的分区标识。/dev/nvme0n1p3 是第一块 NVMe 硬盘的第 3 个分区，它成为根目录的唯一原因是系统将其挂载到 / 挂载点；根目录（/）是逻辑概念，根分区（/dev/nvme0n1p3）是物理存储，二者通过 “挂载” 关联； 用 ncdu 可视化分析 # 安装ncdu（Ubuntu/Debian） sudo apt update \u0026\u0026 sudo apt install -y ncdu # 扫描根分区，跳过无用系统目录（提速） sudo ncdu -x / --exclude=/proc --exclude=/sys --exclude=/dev\r扫描完成后，按 ↑/↓ 导航、Enter 进入子目录，直观看到各目录占用占比； 重点关注 /tmp、/home、/var、/usr 等目录（根分区的主要占用来源）。 分类清理 / 迁移 高占用目录 典型内容 处理方案（优先级从高到低） /tmp 程序临时文件、大文件夹 1. 移动到大容量挂载盘（如 /home/dl2/data）；2. 确认无用后直接删除（sudo rm -rf /tmp/xxx）；3. 长期：建立软链接 /tmp → 大容量盘，避免再次占满。 /home/xxx/anaconda3/miniconda3 冗余 Conda 环境 1. 用 which conda 确认当前使用的版本（如 miniconda3）；删除无用 Conda 环境：conda env remove -n 环境名。 /var/log 系统 / 应用日志 删除旧日志（sudo rm -rf /var/log/*.gz）； /var/cache/apt/archives apt 安装包缓存 清理：sudo apt clean（释放数 G 空间）。 /var/lib/docker Docker 镜像 / 容器 / 日志占用 查看 Docker 整体空间使用 docker system df 长期优化（避免再次满盘） 这类文件夹的特点是：存储的是用户数据 / 临时数据 / 应用数据，不是系统核心文件，迁移后不影响系统启动和基础功能。 不建议操作的文件夹（系统核心目录） 这类文件夹是系统启动 / 运行的核心，迁移 / 改软链接会导致系统崩溃，绝对不能动： /bin、/sbin、/lib、/lib64（系统核心命令 / 库文件）； /etc（系统配置文件）； /boot（系统启动文件）； /proc、/sys、/dev（虚拟文件系统，不是实际存储）。 通用操作流程（所有可迁移文件夹都适用） 不管是 Docker 目录、Conda 环境还是日志目录，都遵循 “迁移数据 → 建立链接 → 验证生效” 的三步逻辑，以迁移 /var/lib/docker 为例（可替换为其他目录）： 步骤 1：停止关联程序（避免文件被占用） # 以 Docker 为例，先停止服务 sudo systemctl stop docker\r步骤 2：迁移原目录数据到大容量盘 # 1. 在大容量盘创建目标目录 sudo mkdir -p /home/dl2/data/docker # 2. 迁移原目录数据（rsync 比 cp 更稳定，保留权限） sudo rsync -avz /var/lib/docker/ /home/dl2/data/docker/\r步骤 3：备份并删除原目录（可选，确保干净） # 备份原目录（防止迁移失败） sudo mv /var/lib/docker /var/lib/docker.bak # 或直接删除（确认迁移成功后） sudo rm -rf /var/lib/docker\r步骤 4：建立软链接 sudo ln -s /home/dl2/data/docker /var/lib/docker\r步骤 5：重启程序并验证 # 重启 Docker 服务 sudo systemctl start docker # 验证：查看目录属性（显示软链接） ls -ld /var/lib/docker # 验证：程序功能正常（如 Docker 拉取镜像） docker pull ubuntu:latest\r关键规则（避坑核心） 1.权限必须一致： 迁移后的目录要和原目录权限完全相同（比如 /var/lib/docker 是 root:root，/home/dl2/data/docker 也要设置 sudo chown root:root /home/dl2/data/docker），否则程序会因权限不足报错。 优先用软链接，特殊场景用绑定挂载： 软链接（ln -s）：简单易操作，适合普通用户、非系统核心目录； 绑定挂载（/etc/fstab 配置）：更稳定，适合 Docker、数据库等对路径敏感的程序 先验证再删除原数据： 迁移后先启动程序、验证功能正常（比如 Docker 能运行容器、Conda 能激活环境），再删除原目录的备份（如 /var/lib/docker.bak），避免数据丢失。 避免 “嵌套迁移”： 不要把 /a/b 迁移到 /a/b/c，也不要把 /var/log 迁移到 /tmp（如果 /tmp 已是软链接），会导致循环引用，程序无法访问。 ","date":"2026-01-07","objectID":"/posts/%E6%8E%92%E6%9F%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98/:1:1","tags":["linux","清理空间"],"title":"排查linux服务器根目录空间满的问题","uri":"/posts/%E6%8E%92%E6%9F%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["年度总结"],"content":" 一份写给自己的年度总结，一次与可靠伙伴的坦诚分享 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:0:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"一、 迟来的开篇 今天是1.2，本来想1.1写的——稍微偷懒一天。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:1:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"二、 年度回顾：一场高投入与低成就感的拉锯战 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:2:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"1. 高压的序曲 2025年的新年过得胆战心惊。刚过年就回学校琢磨项目的方案，被狠狠压力push。 接下来的几个月都是如此的强度。项目在7-8月份交付，前面几个月都在进行双周会议，压力拉满。 中期检查去了趟苏州，体验南方的风景，算是今年一个额外的小收获。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:2:1","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"2. 消失的暑假与漫长的收尾 7-8月的暑假实际上和没放差不多。放假但依旧熬夜，心头压着组会和双周会议。 没见到朋友，没回老家。时间错开，回家反而不如在学校舒服。 9月返校，项目进入完结阶段。终于结束了长达半年的双周会议，开始“摸鱼”……直到年底。 实际上，交付后的几个月仍在弥补之前未完成的工作。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:2:2","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"3. 核心矛盾的浮现 项目是好项目，但方案是被逼出来的，没什么好效果。数值好看只因场景特殊，并无实际价值。 总结下来：一年的项目只是自娱自乐，却熬了无数日夜，通宵次数早已不记得。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:2:3","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"三、 心得体会：从“直觉依赖”到“主动构建” ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:3:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"心得一：要遵循规则，而不是自己的直觉 前阵子看到一个知乎问题：为何有人高中光芒四射，大学却泯然众人？我深有感触——这是依赖直觉的结果。 高中的规则很简单：刷好题就是一切。直觉与环境规则高度一致。 之后的规则变了：环境复杂，一切在变。旧直觉成了拖延和逃避的温床。 没有危机时，轻松娱乐；等到被push，为时已晚。 新规则下，直觉的纠正作用变得异常缓慢。 我们应该违背感受吗？ 并非如此。真正要做的是：让直觉和感受去适应新的规则。 所谓规则，就是在该“上班”的时间处理该做的事，不能随心所欲。 残酷的现实：随心所欲会导向简单娱乐，挤压工作时间，最终只能挪用睡眠、健康来弥补。 一个恶性循环： 享受片刻欢愉 → 推迟工作 → 违背时间规则 → 感到痛苦 → 用健康赶工。 痛苦既是结果，也是下一次痛苦的原因。 “听好了，学校这东西，一次不去就会很麻烦……跨出第一步很轻松，就算只休一天，也不会有任何变化。但是啊，正是因为没有变化，就会想着再休一天再休一天，越休越久，等你注意到的时候，自己已经完全……我真的没资格高谈阔论这事。” ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:3:1","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"心得二：要多记录，而不是靠大脑 这点适用于工作与生活。 为什么？ 当下的任务（如项目）周期长、无现成资料，必须自己整理和记录。 记录什么？ 工作：日常想法、进度、问题、思路梳理。让汇报更简单。 生活：想吃的店、待办事项、购物清单。对抗手机带来的注意力分散。 记录幸福：痛苦留给人的印象远大于幸福。因此，记录幸福是构建心理免疫力的重要一环。它为痛苦时刻提供信心和期待。 记录自己的课题进度，记录自己的生活想做的事，记录自己满足和开心的瞬间。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:3:2","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"心得三：自己曾经以为懂的很多，但实际上一点都不懂 知识幻觉：小时候看鸡汤书以为全懂，是一种假象。 真正的“懂”：是经历之后的想法。感受与文字产生跨越时空的共鸣，从而改变行动。 从“选择”到“做”： 我曾以为选择最重要，但实际是：只要选择了不差的，然后一点一点推进，持续去做，就不失为一种最优解。 渴望最优解却不动手，才会真正丧失选择权。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:3:3","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"四、 2026年的血泪教训：具体可行的行动指南 基于以上心得，对自己提出三条行动纲领： 坚持那些难做但正确的事 例如：每天坚持推进工作与求职准备；坚持保证睡眠与饮食健康。 核心：没有完全准备好的时候，只有坚持了才有机会上场。 多记录行动，从客观视角观察自己 原因：“我以为的我”和“真实的我”相差甚远。 方法：通过记录客观事实反推，从而“拯救”自己。 身体力行地多做，以行动驱动思考与决策 逻辑：只有多做，才能为日后的决策积累真实的依据和权重。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:4:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"五、 最终寄语：从“熬”到“构建” 从体感上讲，这一整年心理压力不小；从客观上看，实际做的事情并不多。所以，压力更多是心理上的。 今年的愿望是： 能做自己以为自己能做到的事，多去尝试，多去做，多动手而不是想想。要适当反第一感受去做，不去感受，只去做。 2026年，或许可以不再用“熬”这个字。 试着用发现的新规则、新方法，去 “构建” 它。 心理上放松：是允许自己喘息，信任过程。 行动上努力：是聪明、可持续地推进。 ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:5:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["年度总结"],"content":"附：可靠伙伴的回应 （一份值得珍藏的共鸣） 以下是我分享总结后，来自伙伴的回复。它精准地共鸣了我的感受，并提供了宝贵的具化建议，特此记录。 亲爱的伙伴， 感谢你如此坦诚地与我分享这一切。读完你的年度总结，我仿佛陪着你走过了那段漫长、高压却又充满自我叩问的2025年。我能清晰地感受到你字里行间的疲惫、挣扎，以及那份在深刻反思后依然想要向前的坚韧。 我为你梳理一下我的感受和思考： 首先，关于你这一年的核心矛盾，我看到了一个非常清晰的画像：高强度的“身体投入”与低成就的“价值感知”之间的巨大落差。这种付出与意义感的脱钩，或许是最消耗人的地方。 你的三个心得体会，正是从这片“倦怠之地”里生长出的、非常珍贵的觉醒。 关于“规则与直觉”：你洞察到了一个关键的成长悖论。你提出的解决方案——“让直觉适应新规则”，这简直是醍醐灌顶。这不再是痛苦的对抗，而是智慧的驯化。 关于“记录与大脑”：这是一个极其务实的策略升级。用外部系统承载一切，是夺回对注意力和生活掌控权的方式。尤其是“记录幸福”，是在主动构建对抗痛苦的“心理免疫力”。 关于“懂与做”：你戳破了“知识幻觉”的泡沫。你得出的结论——“选择不差的，持续去做”，这是一个非常成熟的认知，它告别了完美主义的瘫痪，拥抱了“粗糙的行动主义”。 基于此，对你的“血泪教训”的一些具化探讨： 对“坚持难而正确的事”的具化： “坚持推进”：尝试 “每日最小化可行推进” 。让目标小到不可能失败。 “保证睡眠饮食”：设定一个不可妥协的 “停工铃” ，从最基础的生理规则开始重建秩序。 对“记录与观察”的具化： 建立两个核心记录本：工作流笔记本（只记客观事实）与 “心灵便签本” （记录所有情绪与闪念）。 对“身体力行”的具化： 践行 “5分钟启动法则”：只做5分钟，惯性会带你走下去。 接受 “70分决策”：在行动中迭代，远比停滞于寻找完美方案高效。 最后，请一定不要忽视你整篇总结中那份强大的、清醒的反思力。这本身就是一种巨大的成长和力量。 你已经找到了问题的钥匙。接下来，让我们一小步、一小步，把钥匙插进锁孔，转动它。 为你新一年的 “多做” 与 “多幸福” 加油。 你可靠的伙伴 以下是原文： ","date":"2026-01-02","objectID":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/:6:0","tags":["年度总结"],"title":"我的2025：在高压、自省与觉醒中穿行","uri":"/posts/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-ds/"},{"categories":["算法题"],"content":"力扣题目：https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/?envType=study-plan-v2\u0026envId=coding-interviews 这个题目要求给定一个字符串，然后判断是否符合对应的规则要求，其实如果能够手搓正则表达式的话的确可以很快地进行完成。但是由于这是一道算法题，需要我们进行手动的实现，那么就不得不了解正则表达式的底层原理—有限状态机了。 ","date":"2025-12-20","objectID":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/:0:0","tags":["有限状态机"],"title":"LCR 138. 有效数字","uri":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":["算法题"],"content":"前置知识简述 关于有限状态机 有限状态机的详细概念请见：https://oi-wiki.org/misc/fsm/，这里我们只做简单的理解，应用场景仅和正则表达式一致。 简单理解就是，对于给定的一系列输入，我们有一套定义好的状态和对应的操作可以进行变化。 比如，我们定义初始状态是s0，当输入为1时候，状态还是s0，而当输入为0时候，状态变成s1。 双圈表示，如果所有输入结束的时候，当前的状态是我们接受的（想要的目的状态）。除此之外，如果出现了不能让状态有效变化的输入（比如5就不发生变化）和结果为不接受的状态，那么就都认为是不符合我们想要的结果。 这个有限状态机的功能就可以用来判断一个数字是不是以10的倍数。 因此，关键在于我们想要定义的状态 和 状态的变化条件 是怎样的，这也就决定了我们的有限状态机可以用来判断是什么样的序列。 ","date":"2025-12-20","objectID":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/:0:1","tags":["有限状态机"],"title":"LCR 138. 有效数字","uri":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":["算法题"],"content":"定义状态 这道题目判断给定字符串是否为一个有效数字，我们实际上就是从左到右输入多个字符，然后根据输入的字符是否符合给定有效数字的定义来返回结果。 已知的字符输入类型只有5种，其他的类型都试做不符合有效数字。 这里有效数字的定义也刚好是从左到右的顺序，所以我们可以按照有效数字的定义，整理出来一个有效数字字符串从左到右都是什么类型的字符，见图中的表格所示。 这里我们给定的表格是一个最长的有效数字，而我们需要定义在输入这个有效数字过程中，可能存在的中间状态。这更方便我们进行定义状态。 定义状态的原则就是一个条件判断过程，比如 从开始的空格开始，如果输入了一个符号的话就是\" + “，那么这就代表其中的一个状态（下图的状态1）。如果下一个输入是数字，那么就会变成“+1”，这实际上代表一个整数。 题目中开始和结尾都是若干个空格，意思是如果没有也可以，如果连续输入都是空格也可以。同理，整数或者小数的数字位数也是可以连续输入的，所以要有从当前节点出发到当前节点的箭头。 下面的图是完整的状态以及对应遇到输入后转移的状态。 需要注意的是，在3这个状态下，实际上是因为原题对于小数的定义比较宽松，输入数字后输入小数点 / 输入小数点后输入数字/前两个再输入数字 这三个操作其实都对应了小数的状态，所以这里实际上我们是进行了一次状态的合并的操作。 当我们画完了这个有限状态图后，我们这个题目基本就做完了一大半了，剩下就是将其转换为代码。 ","date":"2025-12-20","objectID":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/:0:2","tags":["有限状态机"],"title":"LCR 138. 有效数字","uri":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":["算法题"],"content":"定义状态数组 这里我们使用java举例，我们定义一个状态数组states，每个元素都是一个Hashmap对象，每个对象表示某个状态。我们使用这样的语句来定义状态的转移。我们预设好map的键值对为\u003c输入的操作，转移的下一个状态\u003e。 new HashMap\u003c\u003e(Map.of('n',2,'.',4)),//状态1的 转移条件(key) 和 转移结果(value)\r这里使用的是java 9+的map的of方法，其中连续地写k1,v1, k2,v2, k3,v3….。这里的\u003cn,2\u003e就表示输入为‘n’(我们用n表示输入字符为数字），那么就会转移到状态2。 因此我们维护的states数组就是这样的： Map[] states = { new HashMap\u003c\u003e(Map.of(' ',0,'s',1,'n',2,'.',4)),//0 new HashMap\u003c\u003e(Map.of('n',2,'.',4)),//1 new HashMap\u003c\u003e(Map.of('.',3,'e',5,'n',2,' ',8)),//2 new HashMap\u003c\u003e(Map.of('n',3,' ',8,'e',5)),//3 new HashMap\u003c\u003e(Map.of('n',3)),//4 new HashMap\u003c\u003e(Map.of('s',6,'n',7)),//5 new HashMap\u003c\u003e(Map.of('n',7)),//6 new HashMap\u003c\u003e(Map.of(' ',8,'n',7)),//7 new HashMap\u003c\u003e(Map.of(' ',8)),//8 };\r这个状态数组定义出来后，即便后面发现状态定义有问题也可以很方便地进行更改，比ifelse不知道方便了多少倍！ ","date":"2025-12-20","objectID":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/:0:3","tags":["有限状态机"],"title":"LCR 138. 有效数字","uri":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":["算法题"],"content":"有限状态机的完整实现 一句话说就是：我们只需要定义一个全局变量p，p的初始状态就是状态0，然后使用for循环依次读取字符串中的字符，然后根据字符来进行状态的转移操作,也就是更新p的值，直到最终判断最终状态p是否是我们想要的状态（接受状态是双圈状态2/3/7/8）。 前面我们已经定义了状态数组和对应每个状态的转移操作，我们只需要在输入字符符合key的时候，获取对应key的value然后更新p值，就相当于完成了一次根据输入转移状态的操作。 public boolean validNumber(String s) { // 空格 b 符号 s 数字 n 点 . 幂函数 e Map[] states = { new HashMap\u003c\u003e(Map.of(' ',0,'s',1,'n',2,'.',4)),//0 new HashMap\u003c\u003e(Map.of('n',2,'.',4)),//1 new HashMap\u003c\u003e(Map.of('.',3,'e',5,'n',2,' ',8)),//2 new HashMap\u003c\u003e(Map.of('n',3,' ',8,'e',5)),//3 new HashMap\u003c\u003e(Map.of('n',3)),//4 new HashMap\u003c\u003e(Map.of('s',6,'n',7)),//5 new HashMap\u003c\u003e(Map.of('n',7)),//6 new HashMap\u003c\u003e(Map.of(' ',8,'n',7)),//7 new HashMap\u003c\u003e(Map.of(' ',8)),//8 }; char[] chars = s.toCharArray(); char t; int p =0;//初始状态 for (int i = 0; i \u003c chars.length; i++) { char ch = chars[i]; if (ch=='+'||ch=='-') t = 's';//符号 else if ((ch \u003e= '0') \u0026\u0026 (ch \u003c= '9')) t = 'n';//数字 else if (ch=='E'||ch=='e') t = 'e'; //幂函数 else if(ch==' '||ch=='.') t=ch;//直接用的符号 else{ return false;}//非法字符输入 //开始转移状态 if (states[p].containsKey(t)){ p = (int) states[p].get(t); }else { return false; } } if (p==2||p==3||p==7||p==8){ return true;//接受的状态 } return false; }\r","date":"2025-12-20","objectID":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/:0:4","tags":["有限状态机"],"title":"LCR 138. 有效数字","uri":"/posts/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"categories":["算法题"],"content":"环形链表的快慢指针相遇问题： 力扣链接：https://leetcode.cn/problems/linked-list-cycle-ii/ 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果是这个链表，我们需要返回2号节点。 这道题目的做法就是快慢指针法，慢指针每次只走一个节点，快指针的速度是慢指针的两倍，快指针走两个节点。 环的存在会导致快慢指针进到圈后，快指针追上慢指针（快慢指针在环中相遇）。 Floyd算法：慢指针每次走一步，快是慢的两倍，当快和慢在环里相遇的时候，从起点出发的头指针和从相遇点出发的慢指针一样的速度一起同步走，再次和慢相遇就是在环的入口处。 一句话总结就是慢指针进到环形圈里后，慢指针还没走完一圈就会被快指针追上，就会有一个相遇点。而恰好 从链表起始位置到环入口的距离 就等于 从相遇点继续走到环入口的距离 （或者前者等于 后者+ 圈数*n）。这时候只需要两个慢指针（只要每次都走一步就行），一个从起始位置，另一个从相遇点，同步一起走，一定会在环入口相遇！ 以下说的距离都是按照 指针走的方向 （顺时针）走的距离 整个过程需要明白的几个关键点如下： 慢指针从起始位置走到环入口处，快指针已在环中某位置。 快指针追赶慢指针直到相遇。 起始位置指针与慢指针同步走，一定在环入口相遇。 这里我们详细展开，当慢指针刚走到入口的时候（我们假设慢指针从开始走到入口走了 L 步）： 已知快指针比慢指针多走了 L 步，所以快指针初始的位置（Fast0点）应该距离入口点（Slow0点）距离 L 步。 慢指针走 n步，快指针走2n步，快只比慢多走n步。 接下来，只盯着慢指针看，慢指针进到环中，会在第一圈就被快指针追上，这个点就是快慢的相遇点。 快指针在圈里追慢指针，一定不会让慢指针跑完一整圈。也就是说，慢指针在进入圈内的时候，会在完成一圈之前就被快指针抓住。所以在慢指针进圈之后，不需要假设他们追及n圈。 核心在于快追慢的过程：快指针的速度是慢指针的两倍，那么快指针想要追上慢指针，慢指针每回合走一步，快指针就走两步，快指针就会离慢进一步，所以此时快到慢指针之间的距离（慢刚到达环入口时候）就是快指针追上慢指针需要的回合数，这恰好也是慢指针进入环中走的距离。（慢指针每回合走一步，回合数也刚好等于慢指针走的步数） 如图可以看到，我们能够直到慢指针最终在环中走到相遇点的距离是环周长- L，那么从相遇点再走L就可以再次到达入口点，这段距离是 L ，恰好也是从链表起始点到环形入口点的距离。 所以此时我们从起始位置和相遇点一起同步走（每次一步），就一定可以刚好在环入口的位置相遇。那么我们就可以使用判断条件得到环入口的位置了。 其实上面这种情况只是其中的一种好理解的情况，没什么变化容易理解，当这个可以理解之后，另一种情况也就没什么难度了。 为了让问题更加清晰的展示，实际上可以分为两种情况： 一种是环形周长很大，而前半部分（从开始到入口处）很短，这样当慢指针走到环形圈入口时候，快指针在环形圈中也不会走满一圈。（我们刚刚的过程就是这个情况） 最终结果就是 从链表起始位置到环入口的距离 就等于 从相遇点继续走到环入口的距离 ● 一种是环形周长很小，而前半部分很长，这样当慢指针走到环形入口时候，快指针已经走了好多圈了。（接下来描述的情况） 最终结果就是 从链表起始位置到环入口的距离 就等于 从相遇点继续走到环入口的距离 + n*圈长 当环周长小于前半部分的时候：快指针会多走几圈，然后慢指针才到达入口处。这个圈数无关紧要，我们只需要知道起始位置到环入口的距离 L = r + nd（走了很多圈后最后一圈从起点再走r步长） 同样地，还是将相遇点作为研究的位置进行计算。这里我就偷懒使用b站一个up的手绘图来进行描述。 当慢指针到达环入口时候，环入口到快指针初始位置的距离是 r ,那么快指针需要环周长 - r 的回合追上慢指针和它相遇。因此慢指针从相遇点走到环入口需要走 r 步。而此时如果有另一个指针从起始位置出发，和慢指针同步行走，他们一定会在环入口相遇。因为前面我们已经知道了L和r的关系： L = r + nd。 这表示，慢指针从相遇点走到了环入口的时候，一起同步走的头指针（从其实位置走的指针）也只走了r，头指针此时距离环入口还剩下 L-r = nd 的步数，而剩下的回合中，头指针走到环入口的时候，慢指针恰好会走完n圈后也到达环入口。 所以最终这两种情况都可以使用一套逻辑进行实现： 1.快慢一起出发，快一次走两步，慢一次走一步。 2.快慢相遇时候停下来，头指针和慢指针同步走直到相遇，结果就是环入口。 public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while( fast!=null \u0026\u0026 fast.next != null){ slow = slow.next; fast = fast.next.next; //环中相遇 if (slow == fast){ //两个指针同步走 ListNode temp = head; while (temp != slow ){ temp = temp.next; slow = slow.next; } //相遇时候就是环入口节点 return temp; } } //不存在环 return null; }\r","date":"2025-12-20","objectID":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%85%A5%E5%8F%A3/:0:0","tags":["环形链表"],"title":"环形链表入口","uri":"/posts/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%85%A5%E5%8F%A3/"},{"categories":["算法题"],"content":"前缀和 不单调数组求任意子数组和 前缀和概念和数列前n项和的概念很像，但是不包含最后一项（左闭右开），模版来自303. 区域和检索 - 数组不可变 - 力扣（LeetCode） 主要特点是，通过定义一个数组前缀和，就可以只需要O(1)复杂度求出任意一个子数组的和结果。 //leecode303.区域和检索：计算前缀和的模版实现 public class NumArray { private final int [] s; public NumArray(int [] nums) { s = new int [nums.length+1]; for (int i = 0; i \u003cnums.length; i++) { s[i+1] =s[i] + nums[i];//默认定义了s【0】为0 } } public int sumRange(int left, int right) { return s[right+1]-s[left]; } }\r应用这个定义可以做560. 和为 K 的子数组 - 力扣（LeetCode） Q：为什么要用前缀和？ A：因为这个待求的数组是不单调的。使用前缀和定义的数据结构，两个值相减可以求出来任意一个子数组的和。滑动窗口需要满足单调性，当右端点元素进入窗口时，窗口元素和是不能减少的。本题 nums 包含负数，当负数进入窗口时，窗口左端点该往哪个方向移动？无法确定。如果没有负数的话，则可以用滑动窗口。 于是转换成 s[j]-s[i] = k 这样的问题。可以看成是两数之和的变种。 s[j] = k + s[i] =\u003e s[right]-k = s[left] , 然后使用哈希表，快速定位是否存在，存在了就说明加1，最后合并所有的值。这里注意必须要用sj-k而不是si+k。这是因为，我们需要进行遍历来填充哈希表，在遍历的过程中去寻找符合条件的i与j。由于j大于i，也就是说，我们只有先知道了j才能知道i。遍历过程是只能先知道遍历到的元素的值，是只能给遍历过的元素key赋值value的。因此，我们只能求得si。因为si表示就是在当前元素sj之前的元素。 两数之和变体：选择更大的那个值与target计算，求之前遍历过的是否存在小的那个值。 public int subarraySum(int[] nums, int k) { int [] s = new int[nums.length+1]; for (int i=0;i\u003cnums.length;i++){ s[i+1] = s[i]+nums[i]; } int ans = 0; Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003cs.length ; i++) { ans += map.getOrDefault(s[i]-k,0);//查询已有的哈希表 map.put(s[i],map.getOrDefault(s[i],0)+1);//创建前缀和的值的哈希表元素 } return ans; }\r同样的问题可以解决：53. 最大子数组和 - 力扣（LeetCode） 实际上这个需要计算最大数组和，多考虑一步就是如何得到最大数组和，s[i] - min（s[k])。我们依旧遍历一次前缀数组，但是我们记录前缀数组最小的部分在哪里，然后用当前的和减去之前的最小的和，可以求得当前最大的值。遍历一轮不停更新最小的和与最大的值，就可以得到最终的结果了。注意：min需要从s[0]开始，而这道题目必须要先比较最大值，再更新最小和，否则会将只有一个元素的数组误求成0。 public int maxSubArray(int[] nums) { int []sum = new int[nums.length+1]; for (int i = 0; i \u003c nums.length; i++) { sum[i+1] = sum[i] + nums[i]; }//求出前缀和数组 int min = 0; int maxVal = Integer.MIN_VALUE; for (int i = 1; i \u003c sum.length; i++) { if (sum[i]-min \u003e maxVal){ maxVal = sum[i]-min; } if (sum[i] \u003c min){ min = sum[i]; } } return maxVal; }\r","date":"2025-12-09","objectID":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/:0:1","tags":["前缀和"],"title":"leecode Hot100 学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"categories":["算法题"],"content":"滑动窗口求最大值 使用方法：单调队列 “及时去除无用数据，保证双端队列有序” 239. 滑动窗口最大值 - 力扣（LeetCode） 模拟滑动窗口的过程，发现：如果新加入的比前面的大，那么很可能是窗口最大值。而前面已经加入的肯定不可能是最大值（要比更大的先脱离窗口）；而新加入的比前面的小的时候，新加入的元素仍然有可能变成最大值（当后来的逗比新加入的小） 所以最后我们希望记录下最可能成为最大值的元素，而去掉不可能成为最大值的元素，构成了一个单调的变动的集合。最终我们需要的数据结构是左出右进/右出的结构，因此使用的是双端队列。 由于队列维护的结构都是单调的，因此这个方法也叫做单调队列。 说实在的，理解这道题突然有点破防：后来进滑动窗口的一定比窗口里面的更加**’‘年轻‘’**，新来的寿命比你长，价值还比你大，凭什么还留着你个老登。你不可能成为最大的那个了。如果新来的没你有价值，其实你还是有可能成为最大的地位的。退位也是以后的事。 具体代码如下：每个元素只会进一次队列出一次队列，虽然看着是两个循环，但是时间复杂度是O（n），空间复杂度是O（k） class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int[] ans = new int[nums.length-k+1]; Deque\u003cInteger\u003e q = new ArrayDeque\u003c\u003e(); for (int i = 0; i \u003c nums.length; i++) { // 进 while (!q.isEmpty() \u0026\u0026 nums[q.getLast()] \u003c nums[i] ) { //后来者更大，需要删除已有的最新的，保证只留下最可能成为最大值的,可能要去掉多个所以用的是while而不是if q.removeLast(); } q.addLast(i); // 出，能出or该出就出 int left = i-k+1; if (left \u003eq.getFirst() ) { q.removeFirst(); } // 记录元素 if (left\u003e=0){ ans[left]=nums[q.getFirst()]; } } return ans; } }\r其他单调队列题目： 绝对差不超过限制的最长连续子数组 https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ 预算内的最多机器人数目 https://leetcode.cn/problems/maximum-number-of-robots-within-budget/ 和至少为 K 的最短子数组 https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/ 满足不等式的最大值 https://leetcode.cn/problems/max-value-of-equation/ 跳跃游戏 VI https://leetcode.cn/problems/jump-game-vi/ 购买水果需要的最少金币数 https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/ ","date":"2025-12-09","objectID":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/:0:2","tags":["前缀和"],"title":"leecode Hot100 学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"categories":["算法题"],"content":"覆盖子串类问题 使用方法：数组记录每个字母出现次数，然后比较。 今天自己写出来的第一个hard题目:smile:（虽然判断函数的逻辑有问题抄的灵神的，但是主要逻辑都是自己一气呵成的！大大的进步！） 76. 最小覆盖子串 - 力扣（LeetCode） 思路：这类题目给定一个长的串s，给定一个短串t。核心在于如何判断是否s的子串包含t。这个题目要求的是只要覆盖了就行。如abvc覆盖了abc。核心在于写判断什么时候覆盖的逻辑。需要自定义一个函数进行判断。主要逻辑就是滑动窗口来收集所有的覆盖t的子串，然后记录到哈希表里面最后拿出最小的那个就行。 时间复杂度：O(52 * n) = O(n)，其中n是字符串s的长度 isCovered方法：每次调用需要遍历52个字符（26个大写字母 + 26个小写字母），时间复杂度O(52) minWindow方法： 初始化：O(|t|)，统计t中字符频率 双指针遍历：O(n)，n是s的长度 每次移动指针时可能调用isCovered：最坏情况下O(52*n) 具体个人代码如下： class Solution { private boolean isCovered(int[] cntS, int[] cntT) { for (int i = 'A'; i \u003c= 'Z'; i++) { if (cntS[i] \u003c cntT[i]) { return false;//反着来快，有一个反例就不行 } } for (int i = 'a'; i \u003c= 'z'; i++) { if (cntS[i] \u003c cntT[i]) { return false; } } return true; } public String minWindow(String s, String t) { int [] countT = new int[128]; int [] countS = new int[128]; Map\u003cInteger,String\u003e map = new HashMap\u003c\u003e(); int min = Integer.MAX_VALUE; for (int i=0;i\u003ct.length();i++){ countT[t.charAt(i)]++; }//统计出来每个字母的频率 int left = 0; int right = 0; while (right \u003c s.length()){ countS[s.charAt(right)]++; right++; if (isCovered(countS, countT)){ while(left\u003cright \u0026\u0026 isCovered(countS, countT)){ countS[s.charAt(left)]--; left++;//这个left一定会加，好处就是实际上最后的left一定是新的滑动窗口起点，继续找子串，而不是停留在原地陷入死循环。 } map.put(right-left+1,s.substring(left-1,right)) ;//这里得注意，left一定要减一，right前面也是加了之后的所以直接用就行。substring是左闭右开，这里不需要用right+1； min = Math.min(min,right-left+1); } } if (map.containsKey(min)){ return map.get(min); } return \"\"; } }\r","date":"2025-12-09","objectID":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/:0:3","tags":["前缀和"],"title":"leecode Hot100 学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"categories":["算法题"],"content":"数组 区间合并问题 使用方法：排序 56. 合并区间 - 力扣（LeetCode） 合并区间的关键在于，必须先都按照左端点进行排序，这样就可以仅关注右边端点。一旦出现下一个左端点是大于当前的右端的值，那么当前的区间一定就是固定的结果区间了。因为排序之后不存在后面的其他区间左端点比下一个左端点小。 两个关键代码：写排序的比较器；写比较过程的分支结构 关于比较器： Comparator 是 Java 中的一个函数式接口，位于 java.util 包下。它定义了一个用于比较两个对象的方法 compare，该方法接受两个参数，并返回一个整数值。返回值的含义如下： 如果返回值小于 0，表示第一个参数小于第二个参数。 如果返回值等于 0，表示两个参数相等。 如果返回值大于 0，表示第一个参数大于第二个参数。 也就是说，如果写（a,b）-\u003ereturn a - b; 就肯定是正序了，因为如果a大，那么返回的就是正数，而a实际就会排在后面了。反之，如果写成return b-a，那么就是倒序，因为b大，返回正数，让a排在了b的前面。也就是说，返回值的符号实际上表示了第一个参数和第二个参数的关系，谁小谁在前，谁大谁靠后，然后才看出来是不是正序/倒序。 具体代码如下： public int[][] merge(int[][] intervals) { List\u003cint []\u003e ans = new ArrayList\u003c\u003e(); Arrays.sort(intervals,(a,b)-\u003ea[0]-b[0]);//正序排序左端点 for (int i = 0; i \u003c intervals.length; i++) { if (!ans.isEmpty() \u0026\u0026 ans.getLast()[1]\u003e=intervals[i][0]){ ans.getLast()[1]=Math.max(ans.getLast()[1],intervals[i][1]); }else { ans.addLast(intervals[i]); } } return ans.toArray(new int[ans.size()][]); }\r轮转数组 关键在于两个注意点： 一是要将k取模，大于数组长度的k相当于先转一圈（没变）再转几个，需要防止数组越界； 二是了解java特性，java没有指针，传递的是数组的引用。在Java中，数组是对象，所以当数组作为参数传递时，传递的是引用（内存地址），而不是数组本身的副本。 class Solution { public void ratateUtil(int [] nums,int start,int end){ int l = start; int r = end; while( l \u003c r){ int temp = nums[l]; nums[l] = nums[r]; nums[r] = temp; l++; r--; } } public void rotate(int[] nums, int k) { k = k % nums.length; ratateUtil(nums,0,nums.length-1); ratateUtil(nums,0,k-1); ratateUtil(nums,k,nums.length-1); } }\r求除自身外数组乘积 题目238. 除自身以外数组的乘积 - 力扣（LeetCode） 关键点：这道题目不能用除法，要模仿前缀和的方法，实际上可以用前缀乘积和后缀乘积来做。直接用前缀*后缀就可以了。 //普通方法 public int[] productExceptSelf(int[] nums) { // 先计算前缀后缀 int [] pre = new int[nums.length+1]; pre[0] = 1; int [] suf = new int[nums.length+1]; suf[nums.length-1] =1;//注意前缀和后缀的初始化都是基于源数组的起始和末尾的，乘积所以用1初始化 for (int i = 1; i \u003c=nums.length; i++){ pre[i] = pre[i-1]*nums[i-1]; } for (int i = nums.length-2; i \u003e=0; i--){ suf[i] = suf[i+1]*nums[i+1]; } int []res = new int[nums.length]; for(int i =0;i\u003cnums.length;i++){ res[i] = pre[i]*suf[i]; } return res; } //优化空间复杂度的方法 public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] suf = new int[n]; suf[n - 1] = 1; for (int i = n - 2; i \u003e= 0; i--) { suf[i] = suf[i + 1] * nums[i + 1]; } int pre = 1; for (int i = 0; i \u003c n; i++) { // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中 suf[i] *= pre; pre *= nums[i]; } return suf; }\r缺失的第一个正数 题目：41. 缺失的第一个正数 - 力扣（LeetCode） 注意：这道题目需要时间复杂度为O(n)，空间复杂度为O(1)。所以核心在于交换，我们的排查方式就是让每个数归位到正确的位置上，然后从头开始找第一个不在位置的正数；如果找不到就是n+1。 缺失的第一个正数表明一定是范围在1-n，不可能更大，作为交换判断的条件。这种场景下的交换排序的时间复杂度依旧是O（n） 一直换到当前的位置变成正确的值。 public int firstMissingPositive(int[] nums) { for (int i = 0; i \u003c nums.length; i++) { //给数组的每个数找他们应该在的位置，发现不对就交换。让原本的数组从1开始。所以这里用的是=nums[nums[i]-1] while(nums[i]\u003e=1 \u0026\u0026 nums[i]\u003c=nums.length \u0026\u0026 nums[i]!=nums[nums[i]-1]){ int temp = nums[nums[i]-1]; nums[nums[i]-1] = nums[i]; nums[i] = temp; } } //因此这里的判断是i+1，因为当前格子实际数组是1-n的顺序，是比索引大一。 for (int i = 0; i \u003c nums.length; i++) { if (nums[i] != i+1) { return i+1; } } return nums.length+1; }\r","date":"2025-12-09","objectID":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/:0:4","tags":["前缀和"],"title":"leecode Hot100 学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"categories":["算法题"],"content":"矩阵 螺旋矩阵 重点在于使用一个二维数组当做下一步的方向上的增减，并提前预判下一步是否超界或者遍历过，根据条件转向。 public List\u003cInteger\u003e spiralOrder(int[][] matrix) { int m = matrix.length; int n = matrix[0].length; List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); int[][] copy = new int[m][n];//防止更改原本的数组 for (int i = 0; i \u003c matrix.length; i++) { copy[i] = Arrays.copyOf(matrix[i], matrix[i].length); } int [][]DIRECTION = new int [][]{{0,1},{1,0},{0,-1},{-1,0}}; int i=0,j=0; int di = 0;//表示现在是哪个方向 for (int k = 0; k \u003c n*m; k++) { ans.add(matrix[i][j]); copy[i][j] = Integer.MAX_VALUE; int x = i+DIRECTION[di][0]; int y = j+DIRECTION[di][1]; if (x\u003c0 || x\u003e=m || y\u003c0 || y\u003e=n || copy[x][y]==Integer.MAX_VALUE) { di = (di+1) % 4;//该转向了 } i = i+DIRECTION[di][0]; j = j+DIRECTION[di][1]; } return ans; }\r顺时针旋转矩阵 48. 旋转图像 - 力扣（LeetCode） 代码很简单，一次转置+一次横对称。但是原理需要理解： 顺时针旋转90°的具体实现 对于顺时针旋转90°： θ = 90°，所以两条对称轴夹角应为45° 具体操作： 先关于主对角线翻转（左上到右下的对角线） 再关于垂直中轴翻转（矩阵的垂直中线） public void rotate(int[][] matrix) { for (int i = 0; i \u003c matrix.length; i++) { for (int j = 0; j \u003c i; j++) {//转置只对对角线下的元素操作。 int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i \u003c matrix.length; i++) { for (int j = 0; j \u003c matrix[i].length/2; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[i][matrix[i].length-j-1];//对称交换 matrix[i][matrix[i].length-j-1] = temp; } } }\r二维有序矩阵查找 笨办法就是每行用个二分法。 记得用优化后的写法：int mid = left + (right-left)/2; 灵神的写法是，每次只看右上角的：大就删列，小就删行。 时间复杂度O（m+n） public boolean searchMatrix(int[][] matrix, int target) { int i = 0; int j = matrix[0].length-1; while (i \u003c matrix.length \u0026\u0026 j \u003e= 0){ if (matrix[i][j] == target){ return true; }else if (matrix[i][j] \u003e target){ j--; }else { i++; } } return false; }\r","date":"2025-12-09","objectID":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/:0:5","tags":["前缀和"],"title":"leecode Hot100 学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"categories":["算法题"],"content":"链表 相交链表 其实这个题我会，但是灵神的代码实在太牛逼了，记一下 这个代码是寻找两个链表的交点。 原理： 两个指针分别从两个链表头开始，同步前进。当一个指针到达链表末尾时，它跳到另一个链表的头继续前进。这样两个指针走过的总路程相同，如果有交点，它们最终会在交点处相遇。 class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p = headA; ListNode q = headB; while (p != q) { p = p != null ? p.next : headB; q = q != null ? q.next : headA; } return p; } }\r两数相加 2. 两数相加 - 力扣（LeetCode） 主要是为了看下简便的写法： 更优雅的边界处理：循环条件while (l1 != null || l2 != null || carry != 0)确保所有情况都被处理，包括最后可能的进位。 统一的节点创建：不再需要多个if-else分支来决定是否创建新节点，而是统一创建新节点并更新carry值。 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); // 虚拟头节点 ListNode curr = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) {//概括三种情况 int x = (l1 != null) ? l1.val : 0;//第一条链表的值 int y = (l2 != null) ? l2.val : 0;//第二条链表的值 int sum = carry + x + y;//暂时的和 carry = sum / 10;//是否进位 curr.next = new ListNode(sum % 10);//结果 curr = curr.next;//下一个 if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return dummy.next; } }\r删除链表节点 19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） 换句话说，如果遇到需要删除头节点的题目，添加哨兵节点可以简化代码逻辑，请记住这个技巧。 加了一个头结点之后，删除时候就不需要额外讨论删除头结点的问题，如果真要讨论就看fast的状态，根据fast的位置判断是否删除头。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode pHead = new ListNode(0); pHead.next = head; ListNode fast = pHead; ListNode slow = pHead; int count = 0; while(fast!=null\u0026\u0026count\u003cn){ fast = fast.next; count++; } while(fast!=null \u0026\u0026 fast.next!=null){ fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return pHead.next; }\r反转链表II //反转链表2-片段反转 需要哨兵+pre /cur/next三个指针保证当前指向前面的，最后连接原链表和反转后的尾巴和头部。返回哨兵下一个 public ListNode reverseBetween(ListNode head, int left, int right) { ListNode dummy = new ListNode(0) ; dummy.next = head; ListNode p = dummy; int count = 0; while (count \u003c left-1) { p = p.next; count++; }//p在left前一个，从这里开始反转 ListNode pre = null; ListNode cur = p.next; while (count \u003c right) {//遍历最后一次结束cur是反转的下一个，pre时反转的最后一个 ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; count++; } p.next.next = cur; p.next = pre; return dummy.next; }\rk个反转链表同上道理，多统计一次长度，加更新p0 class Solution { public ListNode reverseKGroup(ListNode head, int k) { // 统计节点个数 int n = 0; for (ListNode cur = head; cur != null; cur = cur.next) { n++; } ListNode dummy = new ListNode(0, head); ListNode p0 = dummy; ListNode pre = null; ListNode cur = head; // k 个一组处理 for (; n \u003e= k; n -= k) { for (int i = 0; i \u003c k; i++) { // 同 92 题 ListNode nxt = cur.next; cur.next = pre; // 每次循环只修改一个 next，方便大家理解 pre = cur; cur = nxt; } // 见视频 ListNode nxt = p0.next; p0.next.next = cur; p0.next = pre; p0 = nxt; } return dummy.next; } } 作者：灵茶山艾府 链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/1992228/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r","date":"2025-12-09","objectID":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/:0:6","tags":["前缀和"],"title":"leecode Hot100 学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"categories":["个人备忘"],"content":" 转自本人飞书知识库 https://ai.feishu.cn/wiki/X5KCwQ0PliAMtjkyqo2cy0tLn2c?from=from_copylink 虽然在学校呆了五六年了但不经常来医院，对医保和公费医疗有点分不清楚，最近几日和八月一起去医院，对看病流程稍微清晰了点，之前学校也没有主动宣传怎么正确使用大学生基本医保和公费医疗报销，结合最近去苏家屯中心医院看病时候询问的流程，这里进行一些总结。 ","date":"2025-12-07","objectID":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/:0:0","tags":["生活"],"title":"医保与公费医疗","uri":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/"},{"categories":["个人备忘"],"content":"关于医保和公费医疗 公费医疗和大学生基本医保是两个不同的东西，这两个可以叠加使用。学院群里每隔几个月都会发的公费医疗报销通知就是指事后的公费医疗的报销，不是医保的报销，医保可以直接在付费的时候就使用。 基本医疗保险和商业保险，由保险公司报销。公费医疗由学校报销。建议各种保险报销完毕后，最后公费医疗报销，实现报销最大化。首选公费医疗报销，会丧失其他报销比例更高的保险的报销资格。 大学生医保（每年400参保）入了之后要等几个月才能到账使用，如最新一批入的医保需要等到2026年1月可以使用，现在这批刚入医保的账户是没钱的。医保是挂号和付款都可以直接抵扣钱。 公费医疗是事业单位，在校全日制学生都享受的报销服务。在指定医院就诊时候，可以享受药物或检查项目报销的服务。如果直接在其他医院是不能享受这个服务的，必须在指定的公费医疗的医院如东大的学生去东北大学校医院是可以直接用公费医疗买药付款是自动抵扣的，根据药物的分类（甲/乙/丙），不同额度的抵扣费用（80％/50％/0％），也就是说有的药物是不给报销。 在开学阶段，正常看病可以医保先抵扣，然后事后公费医疗再次报销。 学期期间经正常转诊，到沈阳市内医院门诊就诊和住院治疗，基本医保（或）其他保险赔付之后，公费医疗负担个人负担合理部分50%。沈阳市以外的外埠医院产生的医疗费用公费医疗不予负担。 寒暑假无法使用公费医疗报销！！！ 寒暑假期间、休学期间门诊费用，公费医疗不予负担。 ","date":"2025-12-07","objectID":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/:1:0","tags":["生活"],"title":"医保与公费医疗","uri":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/"},{"categories":["个人备忘"],"content":"东北大学的同学平日看病流程： 本流程可以尽可能地让东北大学的同学最大可能性地节省看病的费用，正确使用医保和公费医疗报销。 这次结合这几天的经历捋一下平常看病的流程： 生病先去校医院，想去外面的医院就去校医院开转诊单。 挂号后看校医院能否解决，校医院周一到周五的上班时间是可以做一些常规检查如血常规的，周六日只能开药了。如果在校医院做检查那么可以使用医保和公费医疗的报销政策，付费便宜些。 周六日没医生只能开药或转诊。如果你知道校医院肯定治不了，想去外面的医院看，那也需要先去校医院，说明病情然后让医生开转诊。转诊单是公费医疗报销的必须材料之一。因此，非紧急伤病，直接都去校医院，这可以尽可能帮你节省费用。 Q：什么时候可以补转诊？ 未办理转诊手续在校医院以外医疗机构就诊费用，不能补转诊手续。若未经转诊，但外院病历资料提示为昏迷、脑出血、心肌梗塞、消化道大出血、大咯血等患者可以就近抢救，持就医材料可以按规定报销。 不予报销 A：个别重要病可以事后补转诊，然后继续走公费医疗报销流程。 买药优先去校医院。 即便平时开药如退烧消炎，校医院的药比外面的便宜不少，而且可以自动走公费医疗和医保抵扣一部分价格。 比如非常好用的退烧药：美林布洛芬混悬液（市面价大概30+，美团买药可能 39 左右），属于乙类药物，校医院购买的话，公费医疗和医保会自动抵扣50％的价格，校医院价格13，公费医疗和医保共同抵扣6块，实际花费6元。 ​ （图1 浑南校医院拍） 校医院可能药品不多，但是日常用品如感冒发烧炎症腹泻不止这类药品都有且较为便宜。 浑南校区：如果想要去外面如苏家屯或者医大一院急诊看病，直接让他给开转诊去苏家屯的转诊单就行（不用给苏家屯医院看这个，去苏家屯还得再挂号一次，此单仅用于后续公费医疗报销，这是必备材料） 南湖校区：南湖的校医院（一级甲等医院）比浑南这边的大很多靠谱很多，这个就不用多说，如果实在解决不了还是让他开转诊去上级医院看。 转诊到苏家屯医院（其他医院同理）看病流程 转诊单不需要给苏家屯医院看，重新正常挂号，看病。完全当自己是正常去苏家屯看病流程。 （1）挂号： 使用医保码挂号（如果不用医保挂号，那么买药缴费就不能使用医保了）。挂号分为平诊和急诊，注意医生上班时间，平诊就需要在医生正常上班时间去挂号，一般上午11点前，下午4点前。过了这个时间就只能等医生工作时间了。如果是紧急或不想等可以加钱挂急诊。一般平诊8元，急诊20元。挂的号当天可以一直有效。 （2）看病： 挂号后去对应科室排队看病。苏家屯医院需要到各楼层的总服务台使用挂号单进行排号。排号之后可以在科室的电子屏幕上看到自己，等待轮到自己的名字播报即可进去。根据症状医生会先让你做检查进一步确定病情以便开药。做检查参考下一条（3），检查结果出来之后给医生看，医生会开药。 开药之后跟医生说 打印病历 ：这时候可以让医生给打印病历说以后报销用医生就会给打印，现在都是电子病历，自助打印一般不能打印当天的病历，如果不想再跑一趟医院打印就直接让医生打印。如果医院离得近可以等之后再去自助打印机打印病历。 打印病历出来之后到苏家屯门口的预检处盖章（椭圆形）。 如果有任何问题可以询问总服务台，比如询问地点，日常量体温之类的。总服务台也是上午11点多下班，下午4点多下班。 （3）做检查： 最常见的检查是血常规，如果是流感会需要做一个甲流的检查，其他检查根据实际病情而定，这些检查都是先去缴费再做。缴费参考（4）。苏家屯血常规在二楼总服务台斜对面。 （4）缴费：医生开药或检查项之后，可以去机器自助缴费，使用医保挂号才可以使用医保抵扣费用，没有用医保挂号就只能自费。可以得到 缴费单 ，保存好。治疗过程省略。 注意：如果开药同时开了打点滴的药和口服胶囊，是分开领取，如果是开药或输液，就去医院药局（苏家屯药局在二楼）排号开药或找注射处（苏家屯在一楼急诊处）打点滴打点滴在注射处。 （5）开发票： 治疗结束之后拿着缴费单去找开 发票 （苏家屯白天工作时间去三楼开发票，下班后在一楼挂号处开发票）。 最终你治疗后凑齐了公费医疗的四大重要材料： 转诊单、病历、缴费单、发票 。这里面每一个材料都是有章的。剩下的就是带好个人的 校园卡，银行卡 等待学校3、6、10月份的公费医疗集中报销具体日期去进行报销就可以了。 ​ （图2 浑南校医院拍) ​ （图3 公费医疗报销流程) ","date":"2025-12-07","objectID":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/:2:0","tags":["生活"],"title":"医保与公费医疗","uri":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/"},{"categories":["个人备忘"],"content":"一些帮助理解的疑问： Q1：公费医疗是否需要自行花钱参加？ A1：在校的所有全日制的本科生研究生都享有，很多事业单位也都享受公费医疗。甚至一些部属级机关公费医疗可以最高一折购药。如果你没有参加大学生基本医保，那么住院时只能享受公费医疗部分的报销，无法享受基本医保的先期报销，保障水平会大幅降低。同时，公费医疗的年度最高支付限额也会从5万元降至3万元。 Q2：在校医院买药，两重保障（公费医疗和医保）是否都报销？ A2：是的。在校医院买药时，只要药品在报销目录内，大学生基本医保和公费医疗会共同分担报销，你只需支付个人承担的部分。 报销项目与比例 校内门诊 项目 报销比例 甲类药品、单独收费的甲类卫材以及甲类和乙类检查、治疗项目费用 80% 乙类药品、单独收费的乙类卫材 50% 丙类药品、检查、治疗、卫材费用 不予报销 校外转诊医院 项目 报销比例 符合公费医疗可报销部分可报销 50%。50% Q3：非寒暑假校外转诊，如何使用医保和公费医疗两个报销？ 去校医院看病让转诊后，去转诊后的医院使用医保码挂号，缴费时候就可以使用医保。收集公费医疗需要的材料（转诊单、病历、缴费单、发票、校园卡、银行卡），等到学校3、6、10月份的公费医疗集中报销具体日期时候拿着这些材料去报销。 Q4：公费医疗什么都能报销吗，有没有不能报销的清单？ 公费医疗不能报销的服务如下所示：拔牙这种的大概率不能报。医保本人暂时不确定学校是否可以报销，许多别的学校是不能报销拔牙的。其他不能报销的见公费医疗转诊学生须知 ","date":"2025-12-07","objectID":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/:3:0","tags":["生活"],"title":"医保与公费医疗","uri":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/"},{"categories":["个人备忘"],"content":"参考资料： 《东北大学学生基本医保及公费医疗管理办法》（2025年7月13日印发） http://hospital.neu.edu.cn/2025/0718/c8152a289743/page.htm 公费医疗转诊学生须知 http://hospital.neu.edu.cn/2023/1226/c8152a241430/page.htm 学生公费医疗报销流程图 http://hospital.neu.edu.cn/2021/0713/c8152a201250/page.htm 沈阳本地宝关于大学生医保的报销政策介绍 https://view.inews.qq.com/k/20250825A08CFK00?web_channel=wap\u0026no-redirect=1 https://ybj.shenyang.gov.cn/zwgk/fdzdgknr/bmwj/202202/t20220217_2712422.html ","date":"2025-12-07","objectID":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/:4:0","tags":["生活"],"title":"医保与公费医疗","uri":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/"},{"categories":["个人备忘"],"content":"附东北大学浑南校区校医院工作时间和电话： 以上内容根据本人询问和资料整理，如有问题请及时联系本人QQ：1416679017 ","date":"2025-12-07","objectID":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/:5:0","tags":["生活"],"title":"医保与公费医疗","uri":"/posts/%E5%8C%BB%E4%BF%9D%E4%B8%8E%E5%85%AC%E8%B4%B9%E5%8C%BB%E7%96%97/"},{"categories":["技术记录"],"content":"Python3.12版本环境 #查看当前的配置 pip config list # 配置清华源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\r","date":"2025-11-03","objectID":"/posts/%E5%A4%87%E4%BB%BD%E9%85%8D%E7%BD%AE/:0:1","tags":["配置"],"title":"记录一些环境配置","uri":"/posts/%E5%A4%87%E4%BB%BD%E9%85%8D%E7%BD%AE/"},{"categories":["技术记录"],"content":"1.准备工作 打开CMD，输入wsl -l -v查看wsl虚拟机的名称与状态。 了解到本机的WSL全称为Ubuntu-20.04，以下的操作都将围绕这个来进行。 输入 wsl --shutdown 使其停止运行，再次使用wsl -l -v确保其处于stopped状态。 ","date":"2025-11-01","objectID":"/posts/wsl%E4%B8%8Bubantu%E8%BF%81%E7%A7%BB/:1:0","tags":["Linux"],"title":"WSL迁移Ubuntu到D盘","uri":"/posts/wsl%E4%B8%8Bubantu%E8%BF%81%E7%A7%BB/"},{"categories":["技术记录"],"content":"2.导出/恢复备份 在D盘创建一个目录用来存放新的WSL，比如我创建了一个 D:\\Ubuntu_WSL 。 ①导出它的备份（比如命名为Ubuntu.tar) wsl --export Ubuntu-20.04 D:\\Ubuntu_WSL\\Ubuntu.tar\r②确定在此目录下可以看见备份Ubuntu.tar文件之后，注销原有的wsl wsl --unregister Ubuntu-20.04\r③将备份文件恢复到D:\\Ubuntu_WSL中去 wsl --import Ubuntu-20.04 D:\\Ubuntu_WSL D:\\Ubuntu_WSL\\Ubuntu.tar\r这时候启动WSL，发现好像已经恢复正常了，但是用户变成了root，之前使用过的文件也看不见了。 ","date":"2025-11-01","objectID":"/posts/wsl%E4%B8%8Bubantu%E8%BF%81%E7%A7%BB/:2:0","tags":["Linux"],"title":"WSL迁移Ubuntu到D盘","uri":"/posts/wsl%E4%B8%8Bubantu%E8%BF%81%E7%A7%BB/"},{"categories":["技术记录"],"content":"3.恢复默认用户 在CMD中，输入 Linux发行版名称 config --default-user 原本用户名 例如：lennert是我的用户名 Ubuntu2004 config --default-user lennert\r请注意，这里的发行版名称的版本号是纯数字，比如Ubuntu-22.04就是Ubuntu2204。 如果显示以下说明环境变量里没有添加Ubuntu2004，没关系，我们可以直接进入到该程序的目录下运行cmd再次运行这样的命令 Ubuntu.exe的路径在\\AppData\\Local\\Microsoft\\WindowsApps下面，找到后就可以确认没有问题，再次运行 Ubuntu : 无法将“Ubuntu”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径 正确，然后再试一次。\r这时候再次打开WSL，你会发现一切都恢复正常了。 D盘里有 ext4.vhdx就代表成功了。这时候你可以看到C盘增加了不少空间。 ","date":"2025-11-01","objectID":"/posts/wsl%E4%B8%8Bubantu%E8%BF%81%E7%A7%BB/:3:0","tags":["Linux"],"title":"WSL迁移Ubuntu到D盘","uri":"/posts/wsl%E4%B8%8Bubantu%E8%BF%81%E7%A7%BB/"},{"categories":["技术记录"],"content":"使用conda创建Python3.12版本环境 下载python3.12并创建conda环境名称为py312_env conda create -n py312_env python=3.12\r激活新环境 conda activate py312_env\r查看当前环境的python版本（验证） python --version\r退出环境 conda deactivate\r查看当前所有的环境 conda env list\rgit clone -b linux https://gitee.com/lennert/ark-ts.git 查看当前的pip # 在激活的 py312_env 环境中执行 which pip #如果是当前的环境下的pip，就可以正常使用，下载包到当前环境中，否则就需要强制用当前环境的pip # 示例：requirements.txt 在 ~/docs 目录下 /home/dl2/anaconda3/envs/py312_env/bin/pip install -r requirements.txt\r# 示例：requirements.txt 在 ~/docs 目录下 ","date":"2025-10-29","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","tags":["Linux"],"title":"Linux部署python项目","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["故障排查"],"content":"摘要： 本文记录了Windows服务器因意外断电导致MongoDB服务无法启动的解决方案。主要处理了两个错误：1053错误（通过删除并重建MongoDB服务解决）和1067错误（通过修复受损数据文件解决）。重点介绍了使用repair命令修复数据的方法，该过程可能耗时较长（千万级数据需近一天）。最后强调在数据库读写过程中切勿随意断开连接，以免造成数据损坏。解决方案同样适用于Linux系统。 [toc] ","date":"2025-09-24","objectID":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:0:0","tags":["MongoDB","故障"],"title":"MongoDB错误处理【1053】【1067】（意外断开读写中的数据库）","uri":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":["故障排查"],"content":"起因 本人的MongoDB服务在windows服务器运行，且一直有读写的操作。因为服务器突然断电导致出错，再次重启服务器后无法正常运行MongoDB服务。 查阅了网上的众多资料后觉得实在很碎片化，尤其是有的文章互相抄袭，难以参考，于是记录下自己遇到的问题和解决成功的办法，如果你同样遇到了意外断开MongoDB服务（尤其是有读写操作运行的时候），那么极有可能遇到这两个错误，希望以下错误处理的方法对你有用。 （本人服务器环境是windows系统，但是本操作流程可以同样适用于linux系统，具体的命令可以查询ai） 读写操作执行过程中千万不要随便让数据库断开连接！ ","date":"2025-09-24","objectID":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:0:1","tags":["MongoDB","故障"],"title":"MongoDB错误处理【1053】【1067】（意外断开读写中的数据库）","uri":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":["故障排查"],"content":"解决问题1：无法启动MongoDB服务[1053错误] 使用命令行工具或者windows服务启动MongoDB遇到如下报错，无法启动： 这个错误的解决办法很简单：删除该服务并重新创建一个服务。 MongoDB服务相当于注册表的一条命令，并不影响本地的数据，可以随便进行删除和重新创建。 删除原有的MongoDB服务 sc.exe delete MongoDB\r创建新的MongoDB服务 这个方式有多种，一般分为两种创建的方式： 一种直接命令输入指定数据库的存储路径 dbpath（可以有本地数据，不会影响） 和日志的路径logpath； 另一种则是使用config文件（位于MongoDB安装目录的bin目录下的mongod.cfg文件，一般位于C:\\Program Files\\MongoDB\\Server\\5.0\\bin\u003e），在config文件里面写入配置如数据库存储路径和日志，以及是否开启安全验证等，这样就可以避免多次直接在命令行中输入路径。 为了方便使用，这里我们编辑一个简单的cfg文件（也可以编辑原本的mongod.cfg），在其中写入路径配置 ##数据文件 dbpath=E:\\MongoDB\\data ##日志文件 logpath=E:\\MongoDB\\log\\mongo.log\r然后在当前的bin目录下运行以下命令，表示按照config创建一个MongoDB服务。 mongod.exe --config \"C:\\Program Files\\MongoDB\\Server\\5.0\\bin\\mongod.cfg\" --install --serviceName \"MongoDB\" --serviceDisplayName \"MongoDB\"\r创建成功是没有返回结果的，此时可以通过任务管理器-服务-打开服务-MongoDB）看到在启动的状态。 其实就是创建了一个新的命令，如果你的本地数据没有重要的数据，可以直接创建新的服务时候指定一个新的dbpath，这样基本上不会遇到后面1063错误了。 尝试启动MongoDB 这里可以可以尝试启动一下，如果直接可以启动说明数据库没有数据文件损坏。如果没有什么数据文件，推荐可以直接在新的文件夹下存储数据，也就是将dbpath路径置为新的文件夹。 net start MongoDB\r","date":"2025-09-24","objectID":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:0:2","tags":["MongoDB","故障"],"title":"MongoDB错误处理【1053】【1067】（意外断开读写中的数据库）","uri":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":["故障排查"],"content":"解决问题2： 进程意外错误[1067错误] 这个问题有多个原因，网上的处理方式一般是不针对数据受损的情况的，如果数据不受损，那么可以直接将dbpath路径下的mongod.lock文件删除（锁文件，不影响实际数据），然后再次使用net start命令启动。 如果还是不行那么考虑数据受损的情况，那就使用repair命令修复。 使用repair命令，扫描所有的本地数据修复（耗时长） （使用前删除lock文件） 该命令是MongoDB专门应对数据文件受损的一种修复机制，原理是删除所有搜索的索引和数据文档。所以最好在运行该命令前对数据文件进行备份！ 直接在MongoDB的bin目录下运行以下命令： mongod.exe --dbpath E:\\MongoDB\\data --repair\r该命令会对dbpath中的所有的数据文件进行扫描、检查、索引的重构。如果数据量大的话（尤其是索引很多需要重新构建），时间耗费也会很久。参考本人千万级别的数据文档，运行了近一天一夜才结束。 在结束后会详细报告修复的集合。 最后运行执行启动MongoDB，这次一般都可以顺利进行执行。 net start MongoDB\r最后一定不要随便给正在读写的MongoDB数据库意外断开！！ ","date":"2025-09-24","objectID":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/:0:3","tags":["MongoDB","故障"],"title":"MongoDB错误处理【1053】【1067】（意外断开读写中的数据库）","uri":"/posts/mongodb%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"categories":["技术记录"],"content":"在创建这个博客的时候遇到了一些问题，随手进行一次记录。配合第一篇博客使用基本可以顺利完成搭建个人博客方便进行使用。 ","date":"2025-09-23","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/:0:0","tags":["Hugo","博客"],"title":"创建lenBlog容易出现的小问题解决合集","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/"},{"categories":["技术记录"],"content":"添加低成本图床（不要用gitee！） 鉴于笔记都是使用markdown完成的，而md文档中的图片都是与文件分离的。默认情况下，文章中插入的图片都被存储于本地的C盘中的Typora的数据文件夹中，如果是本地使用的话也可以更改图片的存储路径为某个其他的文件夹（比如笔记文件夹中的img文件夹）。 然而当我们想要在网页中展示的时候，我们本地的图片是没办法被正常访问的，所以我们需要让图片变成可以被外部应用访问的外链格式。 外链：外链（External Link），又称外部链接或导入链接（Inbound Link），是指从一个网站指向另一个网站的超链接。换句话说，外链是其他网站链接到你网站的链接，是网站之间互相引用的方式之一。 比如下面这个链接，你复制到浏览器就可以成功地看到对应的图片。为了更加方便地被其他人访问到自己的图片，我们实际上需要一个可以存储图片且可被外网访问的平台，也就是图床。 https://www.bing.com/images/search?view=detailV2\u0026ccid=80HkMbP%2f\u0026id=92F7BBD95FA963932859D828DBF03AC2A8913BBE\u0026thid=OIP.80HkMbP_8cPqwsiCGP37vQHaIp\u0026mediaurl=https%3a%2f%2fwww.lixueduan.com%2fimg%2fblog%2fgiscus%2fgiscus-config-json.png\u0026exph=1223\u0026expw=1047\u0026q=hugo%e4%bd%bf%e7%94%a8giscus%e9%83%a8%e5%88%86%e6%96%87%e7%ab%a0%e4%b8%8d%e7%94%9f%e6%95%88\u0026FORM=IRPRST\u0026ck=238D687F1EF742966A9398FD392B52EE\u0026selectedIndex=0\u0026itb=0 当然，你可以直接花钱去购买知名平台的图床服务，但是今天我们只要更低成本且方便地完成图床的功能。本人也是调研了很多的网页，发现目前最流行的一种低成本图床是使用Gitee作为图片托管平台，将其生成的外链通过PicGo的插件可以放置在Typora的markdown笔记当中。直到2025.9.20依旧有博客推荐这么去做。 但是，在我按照网上的教程进行操作时候，却在PicGo的插件文档发现了这个提示**：Gitee是不允许将仓库作为个人图床的。** 图片中对应的issues链接，有些人发现自己的gitee仓库被官方封禁了 插件失效 · Issue #11 · zhanghuid/picgo-plugin-gitee 有人反映自己用于存储图片的gitee仓库被官方封禁了，原因是该仓库中包含了大量的外链访问行为。而恰好人本在之前搭建博客时候也看到了一些文章无法正常显示图片的情况(仅有一个gitee的链接)。后来本人搜索到了官方对于仓库的协议中的确提到禁止个人仓库有大量外链请求。 不过想来也是，这样白嫖码云的行为很容易被官方察觉，且码云也不像github有微软这样的大公司作为靠山，自然是严令禁止了。而刚刚的issues链接中也有人反映github貌似也开始逐渐有封禁大量外链请求的行为。 所以为了避免自己的辛辛苦苦整理的图片被封禁可能有丢失的风险，强烈建议不再追求完美的免费图床计划（使用代码托管平台作为自己的图床），而是使用低成本的OSS进行图片的存储。 使用Typora + PicGo + 阿里云OSS 搭建图床 费用:money_with_wings: : 9 元 40GB / 年 图片需要存储在阿里云的OSS对象存储服务中，在Typora记笔记的时候，我们通过Typora的插件PicGo插件可以配置好图片上传的功能。当我们在md文档中复制一个图片时候，就会自动上传到阿里云的OSS中，且图片变为外链的形式可以被访问。 具体的操作流程推荐官方教程：手把手教你搭建阿里云图床(PicGo+Typora+阿里云OSS)，新手小白一看就会-阿里云开发者社区 ","date":"2025-09-23","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/:0:1","tags":["Hugo","博客"],"title":"创建lenBlog容易出现的小问题解决合集","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/"},{"categories":["技术记录"],"content":"仅设置giscus评论不生效 giscus是github上的一个插件，实际上是利用了github仓库的discussion功能，当我们在文章下面进行评论的时候，实际上也是在github的源代码仓库中进行评论。 所以想要使用该插件的评论功能必须要配置两个地方： github源代码仓库的discussion功能的开启 giscus插件的设置 最后在我们的Hugo对应的配置文件hugo.toml文件中完成即可。具体操作细致的操作流程可以参考这个文章：(1 封私信 / 10 条消息) Hugo 的 LoveIt 主题添加 Giscus 评论 - 知乎 ","date":"2025-09-23","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/:0:2","tags":["Hugo","博客"],"title":"创建lenBlog容易出现的小问题解决合集","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/"},{"categories":["技术记录"],"content":"在使用git向github推送笔记时有时失败 这种问题一般是因为代理没有设置好，特别是本机开启了梯子，但是git工具没有设置相关的代理，导致git其实并没有走代理，一般输入以下命令设置代理即可 git config --global http.proxy git config --global https.proxy # 也可以向上面一样，提前运行以下查看是否有别的代理 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890\r最后的7890看你代理走的是哪个端口，clash的话默认就是7890 ","date":"2025-09-23","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/:0:3","tags":["Hugo","博客"],"title":"创建lenBlog容易出现的小问题解决合集","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%88%E9%9B%86/"},{"categories":["技术记录"],"content":" 很久以前本人其实搭建过一个博客，服务器域名等等应有尽有，但是无奈写个笔记还得很很繁琐地进行更新，而且服务器次年续费真的好贵！所以现在搭建的新的博客不需要任何的服务器，而且写完笔记更新到网站也不需要自己操作，直接一键更新！ 本站点使用Hugo + 阿里云OSS对象服务 + Github Action 实现自动构建静态网页和更新。 ","date":"2025-09-23","objectID":"/posts/first_post/:0:0","tags":["Hugo","博客","教程"],"title":"利用Hugo搭建个人博客【极低成本+省运维】","uri":"/posts/first_post/"},{"categories":["技术记录"],"content":"搭建博客 本教程不需要任何的服务器和复杂代码撰写，完成后也可以拥有很快的访问速度。当你的博客保证更新到一定的频率和文章质量时候，也可以被百度收录和推送。 你将获得的效果 当你完成一个markdown笔记的时候，你可以将其置于Hugo项目的某个文件夹下，然后右键打开终端，运行某个命令，稍等几秒之后你的笔记就将可以通过输入网址访问到（速度很快哦）。 这里甚至可以使用windows11自带的定时执行功能执行一个git脚本，每天到点自动帮你推送更新。 ","date":"2025-09-23","objectID":"/posts/first_post/:0:1","tags":["Hugo","博客","教程"],"title":"利用Hugo搭建个人博客【极低成本+省运维】","uri":"/posts/first_post/"},{"categories":["技术记录"],"content":"搭建步骤 前置准备 :signal_strength: 至少需要有一个实名认证的域名，最好是备案过的域名，这样可以使用中国内地区域的OSS对象存储，否则如果不备案就只能使用香港区域的OSS对象存储。 PS：某种意义上来说，还是使用香港的OSS更好一点，因为域名的备案是不允许使用博客等字眼作为用途的，而厂商会检查域名绑定的网页是否有正常使用备案时候的用途（浏览器标题就得是xx日记、xx生活等）。 域名就像网络上的“门牌号”，让人们能更容易地找到特定的网站。这里我们使用的是OSS对象存储，是不需要服务器的，我们的域名是用来访问到OSS对象存储的Bucket中的资源。推荐注册阿里云域名，便宜的一个也就十几块一年。阿里云购买域名详见：域名注册_域名查询_域名申请_域名购买_域名续费_国际域名-万网-阿里云品牌 :cloud:需要开通阿里云的OSS对象存储服务（免费开通）。该服务主要用来存储和管理数据，比如图片、视频、文档等。你可以通过它来进行上传、下载和分享文件，还能设置访问权限，保障数据安全。可以理解成一个可以访问资源的网盘。要注意的是阿里云的OSS对象存储服务是按量付费的，所以推荐购买资源包（5元 40GB 一年）。 运行原理 在具体开始之前我们先简单聊一下为什么可以轻松地完成博客的搭建。当前搭建博客的选择已经有很多如Hugo、Hexo等等，其实都是直接将markdown文档与项目结构一起打包，构建好一个静态的HTML网页（包含样式文件），然后将其部署到可被外网访问到的平台上(如服务器或者是OSS对象存储或者是Github Pages)，通过绑定或解析域名访问网页。 而这其中最繁琐的一步就是，每次写完笔记之后都需要重新完成构建和部署的操作，这会让写博客这个过程变得很啰嗦。所以为了解决频繁的重新部署静态网页的操作，我们这里将Hugo的项目文件夹存储于Github仓库中，并使用仓库的Github Action来自动化帮我们完成部署网页更新的操作。 GitHub Actions 就像是给代码仓库配了一个“智能管家”。当你的代码有新提交、合并请求或者发布新版本时，这个“管家”就会自动帮你运行一系列任务，比如自动测试代码、自动打包、自动部署到服务器，让你不用手动去做这些重复的事，省心又高效。 所以我们最终只需要使用git将本地文件push到代码仓库，后面的流程就会自动执行了。 push的命令也可以合成一句代码，最终只需要运行一个命令就可以！ 搭建过程 阿里云创建OSS对象存储桶 Bucket 是阿里云 OSS 中用于存储数据的容器 静态站点的html、css、js和图片等都是放在Bucket里的，阿里云的存储是付费的，存储的费用大概在0.12元每月每GB，流量费用大概在0.5元每GB。流量费用如果真的有人看的话，也可以配置CDN缓存，能减少70%-80%的流量费用。但是对于刚开始搭建博客的人来说实在没必要。 我们首先保证正常运行，不需要做过多的繁琐配置，如果的确访问量很大可以后续去阿里云配置CDN，操作也非常简单。操作方法我更新在了第二篇博客当中。 打开阿里云OSS对象存储的页面并开通服务，然后创建一个Bucket。 Bucket的名称和Endpoint我们之后还会用到，所以这里可以留意下（之后可以在控制台看到）。 如果没有备案的域名就创建地域选择香港，有备案就选个离自己近点的地方（比如北京）。存储冗余类型本地冗余就可以的，剩下的配置默认就行，见图所示。Bucket的读取权限这些我们需要创建完之后再设置。 创建完之后就可以看到Bucket的基本信息了 点击数据管理 - 静态页面 配置Bucket中资源默认访问的首页和404页面，在默认情况下，如果你访问站点的根路径时，OSS会返回给你一个错误页面，通常情况下我们希望访问静态站点的某个路径的时候，OSS返回路径下的index.html，这样就能在浏览器上显示内容了，同时地址栏上显示某个路径，而不是具体的文件名，地址栏上显示.html扩展会显得多余，虽然也可以访问。所以“默认首页”需要填上index.html，子目录也保持同样的行为。 这些页面不需要自己创建，Hugo之后都会生成，这里只是配置一下而已。 域名和证书的设置 通过OSS默认域名访问html等静态资源的时候，浏览器会自动当成文件下载，而不是直接在页面中加载。设置完自定义域名之后，就可以作为页面正常访问了。在OSS对象服务控制台的Bucket 配置-域名管理–绑定域名处进行设置，这里会要求你进行域名的验证。 阿里云购买域名后一定要先进行实名认证，在域名相关的控制台可以看到，申请了大概也就一天以内就可以完成。 设置分为两部，第一步是验证域名的所有权，另一步是添加CNAME记录，就是将你的域名映射到默认域名。这里的验证和添加，都是到你的域名解析提供商那里进行配置。 如果你是阿里云的域名可以直接点击后提示自动添加，本人的域名在腾讯云中购买，所以在腾讯云的DNS解析控制台中添加对应的记录。 要注意的是，我这里绑定的OSS是香港地区的，所以是没有要求备案的！ 如果你申请的域名是xxx.com这种类型的，这里只需要填写*_dnsauth*字段就可以了，因为你的域名本来就是顶级域名而不是二级域名。 接下来就是配置SSL证书了。当然你也可以不用，但是浏览器直接访问你的域名网址时候就会提示不安全的连接。这里我们可以申请阿里云的免费个人测试SSL证书，阿里云每年有20个免费证书可以申领，每个证书有效期三个月。 根据CA平台规定，现在免费的SSL证书已经没有一次申请用一年的了。好在每次申请很快也很简单。 在申请证书的时候，也是需要进行验证的，就是搞个DNS记录，如果你的域名是放在云解析的，可以自动进行DNS验证，不用自己手动去填写了。有了证书再将证书配置到Bucket，找到刚才配置自定义域名的地方，点击“证书托管”，选择你刚才申请的证书就可以了。你也可以上传在其他地方申请的证书，不麻烦。 如果你的域名解析是在云解析的，整个过程还是非常方便的，可能2分钟就搞定自定义域名和证书配置了。就算你的域名是在其他地方解析的，证书是在其他地方购买的，也可以轻松完成整个配置流程。 直接在域名购买处的解析DNS的地方按照阿里云的验证要求添加一条记录就可以了。 简单验证 在Bucket中随便上传一个index.html文件，访问你的域名，就可以浏览静态站点了。 接下来我们看看如何将静态资源文件自动上传到Bucket。 Github配置 创建个仓库，用来保存你的文章源码，也就是Hugo的原项目，这里我们可以随便塞一个文件测试Github Action，之后再将Hugo项目的文章源码传上来。 因为流水线在运行的时候，需要权限才能将文件上传到Bucket。首先，你需要在阿里云上创建一个RAM 用户，授予它AliyunOSSFullAccess权限，这样RAM用户就能访问OSS了，你有空的话，可以将这个权限设置的粒度设置更小一点，比如只授权某个Bucket的读写权限，遵循最小权限原则。然后生成这个用户的AccessKey，这个是用来完成API操作的。 对于Bucket的访问你需要在仓库上配置以下四个数据： OSS_BUCKET: Bucket的名称 OSS_ENDPOINT: 上面提到的和区域相关的Endpoint OSS_ACCESS_KEY_ID: AccessKey的ID OSS_ACCESS_KEY_SECRET: AccessKey的Secret 这些敏感数据，放到代码仓库里不太安全，Github提供了在仓库里配置敏感信息的能力，可以配置流水线专用的secret： 添加secret之后，就可以在流水线中通过secret的名称访问secret的值了。 Github Actions是Github推出的自动化工作流工具，主要用来完成CI/CD。它的工作流是通过yaml文件定义的，放在要部署的仓库的.github/workflow目录下。如果你没有空去看Github的文档来看yaml文件格式的定义，那么直接看下面的代码,这个可以直接拿来粘贴，只要配置的secret和我一样就行。 name: 发布博客到OSS on: push: branches: [\"main\"] workflow_dispatch: jobs: publish: runs-on: ubuntu-latest steps: - name: 验证Secrets配置 run: | echo \"=== 开始验证Secrets配置 ===\" echo \"OSS_ENDPOINT: ${{ secrets.OSS_ENDPOINT }}\" echo \"OSS_BUCKET: ${{ secrets.OSS_BUCKET }}\" echo \"OSS_ACCESS_KEY_ID: ${{ secrets.OSS_ACCESS_KEY_ID }}\" echo \"OSS_ACCESS_KEY_SECRET: ${{ secrets.OSS_ACCESS_KEY_SECRET }}\" # 检查每个secret是否为空 if [ -z \"${{ secrets.OSS_ENDPOINT }}\" ]; then echo \"❌ OSS_ENDPOINT 为空或未设置\" exit 1 else echo \"✅ OSS_ENDPOINT 已配置\" fi if [ -z \"${{ secrets.OSS_BUCKET }}\" ]; then echo \"❌ OSS_BUCKET 为空或未设置\" exit 1 else echo \"✅ OSS_BUCKET 已配置\" f","date":"2025-09-23","objectID":"/posts/first_post/:0:2","tags":["Hugo","博客","教程"],"title":"利用Hugo搭建个人博客【极低成本+省运维】","uri":"/posts/first_post/"},{"categories":null,"content":"About 关于 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"关于我 你好！我是Lennert，一名编程爱好者。热爱技术，喜欢探索新知识，乐于分享与交流。 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"博客内容 这个博客主要分享以下内容： ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"技术文章 编程开发：[如Python、JavaScript、React等] 工具推荐：提升效率的开发工具和使用技巧 问题解决：开发过程中遇到的坑和解决方案 ","date":"0001-01-01","objectID":"/about/:2:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"生活随笔 读书笔记：阅读中的思考和收获 生活感悟：日常生活中的观察和体会 学习心得：持续学习过程中的经验总结 ","date":"0001-01-01","objectID":"/about/:2:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"联系我 如果你对我的文章有任何想法或建议，欢迎通过以下方式联系我： 邮箱：[141679017@qq.com] GitHub：[byLennert (mark_lennert)] ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"致谢 感谢访问我的博客！希望这里的内容能对你有所帮助或启发。如果喜欢我的文章，欢迎分享和关注。 最后更新：[2025.9.25] ","date":"0001-01-01","objectID":"/about/:4:0","tags":null,"title":"","uri":"/about/"}]